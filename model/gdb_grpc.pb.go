// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package model

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GroupClient is the client API for Group service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GroupClient interface {
	AddGroups(ctx context.Context, in *AddedGroupInfos, opts ...grpc.CallOption) (*Rows, error)
	DeleteGroups(ctx context.Context, in *GroupNamesInfo, opts ...grpc.CallOption) (*Rows, error)
	GetGroups(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GroupNamesInfo, error)
	GetGroupProperty(ctx context.Context, in *QueryGroupPropertyInfo, opts ...grpc.CallOption) (*GroupPropertyInfo, error)
	UpdateGroupNames(ctx context.Context, in *UpdatedGroupNamesInfo, opts ...grpc.CallOption) (*Rows, error)
	UpdateGroupColumnNames(ctx context.Context, in *UpdatedGroupColumnNamesInfo, opts ...grpc.CallOption) (*Cols, error)
	DeleteGroupColumns(ctx context.Context, in *DeletedGroupColumnNamesInfo, opts ...grpc.CallOption) (*Cols, error)
	AddGroupColumns(ctx context.Context, in *AddedGroupColumnsInfo, opts ...grpc.CallOption) (*Cols, error)
}

type groupClient struct {
	cc grpc.ClientConnInterface
}

func NewGroupClient(cc grpc.ClientConnInterface) GroupClient {
	return &groupClient{cc}
}

func (c *groupClient) AddGroups(ctx context.Context, in *AddedGroupInfos, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Group/AddGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) DeleteGroups(ctx context.Context, in *GroupNamesInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Group/DeleteGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) GetGroups(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GroupNamesInfo, error) {
	out := new(GroupNamesInfo)
	err := c.cc.Invoke(ctx, "/model.Group/GetGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) GetGroupProperty(ctx context.Context, in *QueryGroupPropertyInfo, opts ...grpc.CallOption) (*GroupPropertyInfo, error) {
	out := new(GroupPropertyInfo)
	err := c.cc.Invoke(ctx, "/model.Group/GetGroupProperty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) UpdateGroupNames(ctx context.Context, in *UpdatedGroupNamesInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Group/UpdateGroupNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) UpdateGroupColumnNames(ctx context.Context, in *UpdatedGroupColumnNamesInfo, opts ...grpc.CallOption) (*Cols, error) {
	out := new(Cols)
	err := c.cc.Invoke(ctx, "/model.Group/UpdateGroupColumnNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) DeleteGroupColumns(ctx context.Context, in *DeletedGroupColumnNamesInfo, opts ...grpc.CallOption) (*Cols, error) {
	out := new(Cols)
	err := c.cc.Invoke(ctx, "/model.Group/DeleteGroupColumns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) AddGroupColumns(ctx context.Context, in *AddedGroupColumnsInfo, opts ...grpc.CallOption) (*Cols, error) {
	out := new(Cols)
	err := c.cc.Invoke(ctx, "/model.Group/AddGroupColumns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroupServer is the server API for Group service.
// All implementations must embed UnimplementedGroupServer
// for forward compatibility
type GroupServer interface {
	AddGroups(context.Context, *AddedGroupInfos) (*Rows, error)
	DeleteGroups(context.Context, *GroupNamesInfo) (*Rows, error)
	GetGroups(context.Context, *emptypb.Empty) (*GroupNamesInfo, error)
	GetGroupProperty(context.Context, *QueryGroupPropertyInfo) (*GroupPropertyInfo, error)
	UpdateGroupNames(context.Context, *UpdatedGroupNamesInfo) (*Rows, error)
	UpdateGroupColumnNames(context.Context, *UpdatedGroupColumnNamesInfo) (*Cols, error)
	DeleteGroupColumns(context.Context, *DeletedGroupColumnNamesInfo) (*Cols, error)
	AddGroupColumns(context.Context, *AddedGroupColumnsInfo) (*Cols, error)
	mustEmbedUnimplementedGroupServer()
}

// UnimplementedGroupServer must be embedded to have forward compatible implementations.
type UnimplementedGroupServer struct {
}

func (UnimplementedGroupServer) AddGroups(context.Context, *AddedGroupInfos) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGroups not implemented")
}
func (UnimplementedGroupServer) DeleteGroups(context.Context, *GroupNamesInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroups not implemented")
}
func (UnimplementedGroupServer) GetGroups(context.Context, *emptypb.Empty) (*GroupNamesInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroups not implemented")
}
func (UnimplementedGroupServer) GetGroupProperty(context.Context, *QueryGroupPropertyInfo) (*GroupPropertyInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroupProperty not implemented")
}
func (UnimplementedGroupServer) UpdateGroupNames(context.Context, *UpdatedGroupNamesInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroupNames not implemented")
}
func (UnimplementedGroupServer) UpdateGroupColumnNames(context.Context, *UpdatedGroupColumnNamesInfo) (*Cols, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroupColumnNames not implemented")
}
func (UnimplementedGroupServer) DeleteGroupColumns(context.Context, *DeletedGroupColumnNamesInfo) (*Cols, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroupColumns not implemented")
}
func (UnimplementedGroupServer) AddGroupColumns(context.Context, *AddedGroupColumnsInfo) (*Cols, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGroupColumns not implemented")
}
func (UnimplementedGroupServer) mustEmbedUnimplementedGroupServer() {}

// UnsafeGroupServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroupServer will
// result in compilation errors.
type UnsafeGroupServer interface {
	mustEmbedUnimplementedGroupServer()
}

func RegisterGroupServer(s grpc.ServiceRegistrar, srv GroupServer) {
	s.RegisterService(&Group_ServiceDesc, srv)
}

func _Group_AddGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddedGroupInfos)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).AddGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/AddGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).AddGroups(ctx, req.(*AddedGroupInfos))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_DeleteGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupNamesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).DeleteGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/DeleteGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).DeleteGroups(ctx, req.(*GroupNamesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_GetGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).GetGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/GetGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).GetGroups(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_GetGroupProperty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupPropertyInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).GetGroupProperty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/GetGroupProperty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).GetGroupProperty(ctx, req.(*QueryGroupPropertyInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_UpdateGroupNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatedGroupNamesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).UpdateGroupNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/UpdateGroupNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).UpdateGroupNames(ctx, req.(*UpdatedGroupNamesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_UpdateGroupColumnNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatedGroupColumnNamesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).UpdateGroupColumnNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/UpdateGroupColumnNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).UpdateGroupColumnNames(ctx, req.(*UpdatedGroupColumnNamesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_DeleteGroupColumns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletedGroupColumnNamesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).DeleteGroupColumns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/DeleteGroupColumns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).DeleteGroupColumns(ctx, req.(*DeletedGroupColumnNamesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_AddGroupColumns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddedGroupColumnsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).AddGroupColumns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/AddGroupColumns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).AddGroupColumns(ctx, req.(*AddedGroupColumnsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

// Group_ServiceDesc is the grpc.ServiceDesc for Group service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Group_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.Group",
	HandlerType: (*GroupServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddGroups",
			Handler:    _Group_AddGroups_Handler,
		},
		{
			MethodName: "DeleteGroups",
			Handler:    _Group_DeleteGroups_Handler,
		},
		{
			MethodName: "GetGroups",
			Handler:    _Group_GetGroups_Handler,
		},
		{
			MethodName: "GetGroupProperty",
			Handler:    _Group_GetGroupProperty_Handler,
		},
		{
			MethodName: "UpdateGroupNames",
			Handler:    _Group_UpdateGroupNames_Handler,
		},
		{
			MethodName: "UpdateGroupColumnNames",
			Handler:    _Group_UpdateGroupColumnNames_Handler,
		},
		{
			MethodName: "DeleteGroupColumns",
			Handler:    _Group_DeleteGroupColumns_Handler,
		},
		{
			MethodName: "AddGroupColumns",
			Handler:    _Group_AddGroupColumns_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gdb.proto",
}

// ItemClient is the client API for Item service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ItemClient interface {
	AddItems(ctx context.Context, in *AddedItemsInfo, opts ...grpc.CallOption) (*Rows, error)
	DeleteItems(ctx context.Context, in *DeletedItemsInfo, opts ...grpc.CallOption) (*Rows, error)
	GetItems(ctx context.Context, in *ItemsInfo, opts ...grpc.CallOption) (*GdbItems, error)
	GetItemsWithCount(ctx context.Context, in *ItemsInfo, opts ...grpc.CallOption) (*GdbItemsWithCount, error)
	UpdateItems(ctx context.Context, in *UpdatedItemsInfo, opts ...grpc.CallOption) (*Rows, error)
	CheckItems(ctx context.Context, in *CheckItemsInfo, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CleanGroupItems(ctx context.Context, in *GroupNamesInfo, opts ...grpc.CallOption) (*Rows, error)
}

type itemClient struct {
	cc grpc.ClientConnInterface
}

func NewItemClient(cc grpc.ClientConnInterface) ItemClient {
	return &itemClient{cc}
}

func (c *itemClient) AddItems(ctx context.Context, in *AddedItemsInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Item/AddItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) DeleteItems(ctx context.Context, in *DeletedItemsInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Item/DeleteItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) GetItems(ctx context.Context, in *ItemsInfo, opts ...grpc.CallOption) (*GdbItems, error) {
	out := new(GdbItems)
	err := c.cc.Invoke(ctx, "/model.Item/GetItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) GetItemsWithCount(ctx context.Context, in *ItemsInfo, opts ...grpc.CallOption) (*GdbItemsWithCount, error) {
	out := new(GdbItemsWithCount)
	err := c.cc.Invoke(ctx, "/model.Item/GetItemsWithCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) UpdateItems(ctx context.Context, in *UpdatedItemsInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Item/UpdateItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) CheckItems(ctx context.Context, in *CheckItemsInfo, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/model.Item/CheckItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) CleanGroupItems(ctx context.Context, in *GroupNamesInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Item/CleanGroupItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ItemServer is the server API for Item service.
// All implementations must embed UnimplementedItemServer
// for forward compatibility
type ItemServer interface {
	AddItems(context.Context, *AddedItemsInfo) (*Rows, error)
	DeleteItems(context.Context, *DeletedItemsInfo) (*Rows, error)
	GetItems(context.Context, *ItemsInfo) (*GdbItems, error)
	GetItemsWithCount(context.Context, *ItemsInfo) (*GdbItemsWithCount, error)
	UpdateItems(context.Context, *UpdatedItemsInfo) (*Rows, error)
	CheckItems(context.Context, *CheckItemsInfo) (*emptypb.Empty, error)
	CleanGroupItems(context.Context, *GroupNamesInfo) (*Rows, error)
	mustEmbedUnimplementedItemServer()
}

// UnimplementedItemServer must be embedded to have forward compatible implementations.
type UnimplementedItemServer struct {
}

func (UnimplementedItemServer) AddItems(context.Context, *AddedItemsInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddItems not implemented")
}
func (UnimplementedItemServer) DeleteItems(context.Context, *DeletedItemsInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteItems not implemented")
}
func (UnimplementedItemServer) GetItems(context.Context, *ItemsInfo) (*GdbItems, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetItems not implemented")
}
func (UnimplementedItemServer) GetItemsWithCount(context.Context, *ItemsInfo) (*GdbItemsWithCount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetItemsWithCount not implemented")
}
func (UnimplementedItemServer) UpdateItems(context.Context, *UpdatedItemsInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateItems not implemented")
}
func (UnimplementedItemServer) CheckItems(context.Context, *CheckItemsInfo) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckItems not implemented")
}
func (UnimplementedItemServer) CleanGroupItems(context.Context, *GroupNamesInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanGroupItems not implemented")
}
func (UnimplementedItemServer) mustEmbedUnimplementedItemServer() {}

// UnsafeItemServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ItemServer will
// result in compilation errors.
type UnsafeItemServer interface {
	mustEmbedUnimplementedItemServer()
}

func RegisterItemServer(s grpc.ServiceRegistrar, srv ItemServer) {
	s.RegisterService(&Item_ServiceDesc, srv)
}

func _Item_AddItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddedItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).AddItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/AddItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).AddItems(ctx, req.(*AddedItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_DeleteItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletedItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).DeleteItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/DeleteItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).DeleteItems(ctx, req.(*DeletedItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_GetItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).GetItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/GetItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).GetItems(ctx, req.(*ItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_GetItemsWithCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).GetItemsWithCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/GetItemsWithCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).GetItemsWithCount(ctx, req.(*ItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_UpdateItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatedItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).UpdateItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/UpdateItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).UpdateItems(ctx, req.(*UpdatedItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_CheckItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).CheckItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/CheckItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).CheckItems(ctx, req.(*CheckItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_CleanGroupItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupNamesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).CleanGroupItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/CleanGroupItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).CleanGroupItems(ctx, req.(*GroupNamesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

// Item_ServiceDesc is the grpc.ServiceDesc for Item service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Item_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.Item",
	HandlerType: (*ItemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddItems",
			Handler:    _Item_AddItems_Handler,
		},
		{
			MethodName: "DeleteItems",
			Handler:    _Item_DeleteItems_Handler,
		},
		{
			MethodName: "GetItems",
			Handler:    _Item_GetItems_Handler,
		},
		{
			MethodName: "GetItemsWithCount",
			Handler:    _Item_GetItemsWithCount_Handler,
		},
		{
			MethodName: "UpdateItems",
			Handler:    _Item_UpdateItems_Handler,
		},
		{
			MethodName: "CheckItems",
			Handler:    _Item_CheckItems_Handler,
		},
		{
			MethodName: "CleanGroupItems",
			Handler:    _Item_CleanGroupItems_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gdb.proto",
}

// DataClient is the client API for Data service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataClient interface {
	BatchWrite(ctx context.Context, in *BatchWriteString, opts ...grpc.CallOption) (*Rows, error)
	BatchWriteWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteWithStreamClient, error)
	BatchWriteHistoricalData(ctx context.Context, in *BatchWriteHistoricalString, opts ...grpc.CallOption) (*emptypb.Empty, error)
	BatchWriteHistoricalDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteHistoricalDataWithStreamClient, error)
	GetRealTimeData(ctx context.Context, in *QueryRealTimeDataString, opts ...grpc.CallOption) (*GdbRealTimeData, error)
	GetHistoricalData(ctx context.Context, in *QueryHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetHistoricalDataWithStamp(ctx context.Context, in *QueryHistoricalDataWithTimeStampString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetHistoricalDataWithCondition(ctx context.Context, in *QueryHistoricalDataWithConditionString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetRawData(ctx context.Context, in *QueryRealTimeDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
}

type dataClient struct {
	cc grpc.ClientConnInterface
}

func NewDataClient(cc grpc.ClientConnInterface) DataClient {
	return &dataClient{cc}
}

func (c *dataClient) BatchWrite(ctx context.Context, in *BatchWriteString, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Data/BatchWrite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) BatchWriteWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Data_ServiceDesc.Streams[0], "/model.Data/BatchWriteWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBatchWriteWithStreamClient{stream}
	return x, nil
}

type Data_BatchWriteWithStreamClient interface {
	Send(*BatchWriteString) error
	CloseAndRecv() (*Rows, error)
	grpc.ClientStream
}

type dataBatchWriteWithStreamClient struct {
	grpc.ClientStream
}

func (x *dataBatchWriteWithStreamClient) Send(m *BatchWriteString) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBatchWriteWithStreamClient) CloseAndRecv() (*Rows, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Rows)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataClient) BatchWriteHistoricalData(ctx context.Context, in *BatchWriteHistoricalString, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/model.Data/BatchWriteHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) BatchWriteHistoricalDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteHistoricalDataWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Data_ServiceDesc.Streams[1], "/model.Data/BatchWriteHistoricalDataWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBatchWriteHistoricalDataWithStreamClient{stream}
	return x, nil
}

type Data_BatchWriteHistoricalDataWithStreamClient interface {
	Send(*BatchWriteHistoricalString) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type dataBatchWriteHistoricalDataWithStreamClient struct {
	grpc.ClientStream
}

func (x *dataBatchWriteHistoricalDataWithStreamClient) Send(m *BatchWriteHistoricalString) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBatchWriteHistoricalDataWithStreamClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataClient) GetRealTimeData(ctx context.Context, in *QueryRealTimeDataString, opts ...grpc.CallOption) (*GdbRealTimeData, error) {
	out := new(GdbRealTimeData)
	err := c.cc.Invoke(ctx, "/model.Data/GetRealTimeData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetHistoricalData(ctx context.Context, in *QueryHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetHistoricalDataWithStamp(ctx context.Context, in *QueryHistoricalDataWithTimeStampString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetHistoricalDataWithStamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetHistoricalDataWithCondition(ctx context.Context, in *QueryHistoricalDataWithConditionString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetHistoricalDataWithCondition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetRawData(ctx context.Context, in *QueryRealTimeDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetRawData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataServer is the server API for Data service.
// All implementations must embed UnimplementedDataServer
// for forward compatibility
type DataServer interface {
	BatchWrite(context.Context, *BatchWriteString) (*Rows, error)
	BatchWriteWithStream(Data_BatchWriteWithStreamServer) error
	BatchWriteHistoricalData(context.Context, *BatchWriteHistoricalString) (*emptypb.Empty, error)
	BatchWriteHistoricalDataWithStream(Data_BatchWriteHistoricalDataWithStreamServer) error
	GetRealTimeData(context.Context, *QueryRealTimeDataString) (*GdbRealTimeData, error)
	GetHistoricalData(context.Context, *QueryHistoricalDataString) (*GdbHistoricalData, error)
	GetHistoricalDataWithStamp(context.Context, *QueryHistoricalDataWithTimeStampString) (*GdbHistoricalData, error)
	GetHistoricalDataWithCondition(context.Context, *QueryHistoricalDataWithConditionString) (*GdbHistoricalData, error)
	GetRawData(context.Context, *QueryRealTimeDataString) (*GdbHistoricalData, error)
	mustEmbedUnimplementedDataServer()
}

// UnimplementedDataServer must be embedded to have forward compatible implementations.
type UnimplementedDataServer struct {
}

func (UnimplementedDataServer) BatchWrite(context.Context, *BatchWriteString) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchWrite not implemented")
}
func (UnimplementedDataServer) BatchWriteWithStream(Data_BatchWriteWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchWriteWithStream not implemented")
}
func (UnimplementedDataServer) BatchWriteHistoricalData(context.Context, *BatchWriteHistoricalString) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchWriteHistoricalData not implemented")
}
func (UnimplementedDataServer) BatchWriteHistoricalDataWithStream(Data_BatchWriteHistoricalDataWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchWriteHistoricalDataWithStream not implemented")
}
func (UnimplementedDataServer) GetRealTimeData(context.Context, *QueryRealTimeDataString) (*GdbRealTimeData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRealTimeData not implemented")
}
func (UnimplementedDataServer) GetHistoricalData(context.Context, *QueryHistoricalDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistoricalData not implemented")
}
func (UnimplementedDataServer) GetHistoricalDataWithStamp(context.Context, *QueryHistoricalDataWithTimeStampString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistoricalDataWithStamp not implemented")
}
func (UnimplementedDataServer) GetHistoricalDataWithCondition(context.Context, *QueryHistoricalDataWithConditionString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistoricalDataWithCondition not implemented")
}
func (UnimplementedDataServer) GetRawData(context.Context, *QueryRealTimeDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRawData not implemented")
}
func (UnimplementedDataServer) mustEmbedUnimplementedDataServer() {}

// UnsafeDataServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataServer will
// result in compilation errors.
type UnsafeDataServer interface {
	mustEmbedUnimplementedDataServer()
}

func RegisterDataServer(s grpc.ServiceRegistrar, srv DataServer) {
	s.RegisterService(&Data_ServiceDesc, srv)
}

func _Data_BatchWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchWriteString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).BatchWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/BatchWrite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).BatchWrite(ctx, req.(*BatchWriteString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_BatchWriteWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServer).BatchWriteWithStream(&dataBatchWriteWithStreamServer{stream})
}

type Data_BatchWriteWithStreamServer interface {
	SendAndClose(*Rows) error
	Recv() (*BatchWriteString, error)
	grpc.ServerStream
}

type dataBatchWriteWithStreamServer struct {
	grpc.ServerStream
}

func (x *dataBatchWriteWithStreamServer) SendAndClose(m *Rows) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBatchWriteWithStreamServer) Recv() (*BatchWriteString, error) {
	m := new(BatchWriteString)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Data_BatchWriteHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchWriteHistoricalString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).BatchWriteHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/BatchWriteHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).BatchWriteHistoricalData(ctx, req.(*BatchWriteHistoricalString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_BatchWriteHistoricalDataWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServer).BatchWriteHistoricalDataWithStream(&dataBatchWriteHistoricalDataWithStreamServer{stream})
}

type Data_BatchWriteHistoricalDataWithStreamServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*BatchWriteHistoricalString, error)
	grpc.ServerStream
}

type dataBatchWriteHistoricalDataWithStreamServer struct {
	grpc.ServerStream
}

func (x *dataBatchWriteHistoricalDataWithStreamServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBatchWriteHistoricalDataWithStreamServer) Recv() (*BatchWriteHistoricalString, error) {
	m := new(BatchWriteHistoricalString)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Data_GetRealTimeData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRealTimeDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetRealTimeData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetRealTimeData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetRealTimeData(ctx, req.(*QueryRealTimeDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetHistoricalData(ctx, req.(*QueryHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetHistoricalDataWithStamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataWithTimeStampString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetHistoricalDataWithStamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetHistoricalDataWithStamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetHistoricalDataWithStamp(ctx, req.(*QueryHistoricalDataWithTimeStampString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetHistoricalDataWithCondition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataWithConditionString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetHistoricalDataWithCondition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetHistoricalDataWithCondition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetHistoricalDataWithCondition(ctx, req.(*QueryHistoricalDataWithConditionString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetRawData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRealTimeDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetRawData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetRawData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetRawData(ctx, req.(*QueryRealTimeDataString))
	}
	return interceptor(ctx, in, info, handler)
}

// Data_ServiceDesc is the grpc.ServiceDesc for Data service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Data_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.Data",
	HandlerType: (*DataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BatchWrite",
			Handler:    _Data_BatchWrite_Handler,
		},
		{
			MethodName: "BatchWriteHistoricalData",
			Handler:    _Data_BatchWriteHistoricalData_Handler,
		},
		{
			MethodName: "GetRealTimeData",
			Handler:    _Data_GetRealTimeData_Handler,
		},
		{
			MethodName: "GetHistoricalData",
			Handler:    _Data_GetHistoricalData_Handler,
		},
		{
			MethodName: "GetHistoricalDataWithStamp",
			Handler:    _Data_GetHistoricalDataWithStamp_Handler,
		},
		{
			MethodName: "GetHistoricalDataWithCondition",
			Handler:    _Data_GetHistoricalDataWithCondition_Handler,
		},
		{
			MethodName: "GetRawData",
			Handler:    _Data_GetRawData_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BatchWriteWithStream",
			Handler:       _Data_BatchWriteWithStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchWriteHistoricalDataWithStream",
			Handler:       _Data_BatchWriteHistoricalDataWithStream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gdb.proto",
}

// PageClient is the client API for Page service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PageClient interface {
	UserLogin(ctx context.Context, in *AuthInfo, opts ...grpc.CallOption) (*UserToken, error)
	UserLogOut(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetUserInfo(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*UserInfo, error)
	GetUsers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserInfos, error)
	AddUsers(ctx context.Context, in *AddUserInfo, opts ...grpc.CallOption) (*Rows, error)
	DeleteUsers(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*Rows, error)
	UpdateUsers(ctx context.Context, in *UpdatedUserInfo, opts ...grpc.CallOption) (*Rows, error)
	UploadFile(ctx context.Context, in *UploadedFileInfo, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UploadFileWithStream(ctx context.Context, opts ...grpc.CallOption) (Page_UploadFileWithStreamClient, error)
	AddItemsByExcel(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*Rows, error)
	ImportHistoryByExcel(ctx context.Context, in *HistoryFileInfo, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetLogs(ctx context.Context, in *QueryLogsInfo, opts ...grpc.CallOption) (*LogsInfo, error)
	DeleteLogs(ctx context.Context, in *DeletedLogInfo, opts ...grpc.CallOption) (*Rows, error)
	DownloadFile(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileContents, error)
	GetDbInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GdbInfoData, error)
	GetDbInfoHistory(ctx context.Context, in *QuerySpeedHistoryDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetRoutes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Routes, error)
	DeleteRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*Rows, error)
	AddRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*Rows, error)
	AddUserRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*Rows, error)
	DeleteUserRoutes(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*Rows, error)
	GetAllRoutes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Routes, error)
	CheckRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*CheckResult, error)
}

type pageClient struct {
	cc grpc.ClientConnInterface
}

func NewPageClient(cc grpc.ClientConnInterface) PageClient {
	return &pageClient{cc}
}

func (c *pageClient) UserLogin(ctx context.Context, in *AuthInfo, opts ...grpc.CallOption) (*UserToken, error) {
	out := new(UserToken)
	err := c.cc.Invoke(ctx, "/model.Page/UserLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) UserLogOut(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/model.Page/UserLogOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetUserInfo(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*UserInfo, error) {
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, "/model.Page/GetUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetUsers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserInfos, error) {
	out := new(UserInfos)
	err := c.cc.Invoke(ctx, "/model.Page/GetUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) AddUsers(ctx context.Context, in *AddUserInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Page/AddUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) DeleteUsers(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Page/DeleteUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) UpdateUsers(ctx context.Context, in *UpdatedUserInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Page/UpdateUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) UploadFile(ctx context.Context, in *UploadedFileInfo, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/model.Page/UploadFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) UploadFileWithStream(ctx context.Context, opts ...grpc.CallOption) (Page_UploadFileWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Page_ServiceDesc.Streams[0], "/model.Page/UploadFileWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &pageUploadFileWithStreamClient{stream}
	return x, nil
}

type Page_UploadFileWithStreamClient interface {
	Send(*UploadedFileInfo) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type pageUploadFileWithStreamClient struct {
	grpc.ClientStream
}

func (x *pageUploadFileWithStreamClient) Send(m *UploadedFileInfo) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pageUploadFileWithStreamClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pageClient) AddItemsByExcel(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Page/AddItemsByExcel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) ImportHistoryByExcel(ctx context.Context, in *HistoryFileInfo, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/model.Page/ImportHistoryByExcel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetLogs(ctx context.Context, in *QueryLogsInfo, opts ...grpc.CallOption) (*LogsInfo, error) {
	out := new(LogsInfo)
	err := c.cc.Invoke(ctx, "/model.Page/GetLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) DeleteLogs(ctx context.Context, in *DeletedLogInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Page/DeleteLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) DownloadFile(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileContents, error) {
	out := new(FileContents)
	err := c.cc.Invoke(ctx, "/model.Page/DownloadFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetDbInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GdbInfoData, error) {
	out := new(GdbInfoData)
	err := c.cc.Invoke(ctx, "/model.Page/GetDbInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetDbInfoHistory(ctx context.Context, in *QuerySpeedHistoryDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Page/GetDbInfoHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetRoutes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Routes, error) {
	out := new(Routes)
	err := c.cc.Invoke(ctx, "/model.Page/GetRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) DeleteRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Page/DeleteRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) AddRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Page/AddRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) AddUserRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Page/AddUserRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) DeleteUserRoutes(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Page/DeleteUserRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetAllRoutes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Routes, error) {
	out := new(Routes)
	err := c.cc.Invoke(ctx, "/model.Page/GetAllRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) CheckRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*CheckResult, error) {
	out := new(CheckResult)
	err := c.cc.Invoke(ctx, "/model.Page/CheckRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PageServer is the server API for Page service.
// All implementations must embed UnimplementedPageServer
// for forward compatibility
type PageServer interface {
	UserLogin(context.Context, *AuthInfo) (*UserToken, error)
	UserLogOut(context.Context, *UserName) (*emptypb.Empty, error)
	GetUserInfo(context.Context, *UserName) (*UserInfo, error)
	GetUsers(context.Context, *emptypb.Empty) (*UserInfos, error)
	AddUsers(context.Context, *AddUserInfo) (*Rows, error)
	DeleteUsers(context.Context, *UserName) (*Rows, error)
	UpdateUsers(context.Context, *UpdatedUserInfo) (*Rows, error)
	UploadFile(context.Context, *UploadedFileInfo) (*emptypb.Empty, error)
	UploadFileWithStream(Page_UploadFileWithStreamServer) error
	AddItemsByExcel(context.Context, *FileInfo) (*Rows, error)
	ImportHistoryByExcel(context.Context, *HistoryFileInfo) (*emptypb.Empty, error)
	GetLogs(context.Context, *QueryLogsInfo) (*LogsInfo, error)
	DeleteLogs(context.Context, *DeletedLogInfo) (*Rows, error)
	DownloadFile(context.Context, *FileInfo) (*FileContents, error)
	GetDbInfo(context.Context, *emptypb.Empty) (*GdbInfoData, error)
	GetDbInfoHistory(context.Context, *QuerySpeedHistoryDataString) (*GdbHistoricalData, error)
	GetRoutes(context.Context, *emptypb.Empty) (*Routes, error)
	DeleteRoutes(context.Context, *RoutesInfo) (*Rows, error)
	AddRoutes(context.Context, *RoutesInfo) (*Rows, error)
	AddUserRoutes(context.Context, *RoutesInfo) (*Rows, error)
	DeleteUserRoutes(context.Context, *UserName) (*Rows, error)
	GetAllRoutes(context.Context, *emptypb.Empty) (*Routes, error)
	CheckRoutes(context.Context, *RoutesInfo) (*CheckResult, error)
	mustEmbedUnimplementedPageServer()
}

// UnimplementedPageServer must be embedded to have forward compatible implementations.
type UnimplementedPageServer struct {
}

func (UnimplementedPageServer) UserLogin(context.Context, *AuthInfo) (*UserToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedPageServer) UserLogOut(context.Context, *UserName) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogOut not implemented")
}
func (UnimplementedPageServer) GetUserInfo(context.Context, *UserName) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedPageServer) GetUsers(context.Context, *emptypb.Empty) (*UserInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}
func (UnimplementedPageServer) AddUsers(context.Context, *AddUserInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUsers not implemented")
}
func (UnimplementedPageServer) DeleteUsers(context.Context, *UserName) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUsers not implemented")
}
func (UnimplementedPageServer) UpdateUsers(context.Context, *UpdatedUserInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUsers not implemented")
}
func (UnimplementedPageServer) UploadFile(context.Context, *UploadedFileInfo) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (UnimplementedPageServer) UploadFileWithStream(Page_UploadFileWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadFileWithStream not implemented")
}
func (UnimplementedPageServer) AddItemsByExcel(context.Context, *FileInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddItemsByExcel not implemented")
}
func (UnimplementedPageServer) ImportHistoryByExcel(context.Context, *HistoryFileInfo) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportHistoryByExcel not implemented")
}
func (UnimplementedPageServer) GetLogs(context.Context, *QueryLogsInfo) (*LogsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogs not implemented")
}
func (UnimplementedPageServer) DeleteLogs(context.Context, *DeletedLogInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLogs not implemented")
}
func (UnimplementedPageServer) DownloadFile(context.Context, *FileInfo) (*FileContents, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadFile not implemented")
}
func (UnimplementedPageServer) GetDbInfo(context.Context, *emptypb.Empty) (*GdbInfoData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDbInfo not implemented")
}
func (UnimplementedPageServer) GetDbInfoHistory(context.Context, *QuerySpeedHistoryDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDbInfoHistory not implemented")
}
func (UnimplementedPageServer) GetRoutes(context.Context, *emptypb.Empty) (*Routes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutes not implemented")
}
func (UnimplementedPageServer) DeleteRoutes(context.Context, *RoutesInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoutes not implemented")
}
func (UnimplementedPageServer) AddRoutes(context.Context, *RoutesInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRoutes not implemented")
}
func (UnimplementedPageServer) AddUserRoutes(context.Context, *RoutesInfo) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserRoutes not implemented")
}
func (UnimplementedPageServer) DeleteUserRoutes(context.Context, *UserName) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserRoutes not implemented")
}
func (UnimplementedPageServer) GetAllRoutes(context.Context, *emptypb.Empty) (*Routes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllRoutes not implemented")
}
func (UnimplementedPageServer) CheckRoutes(context.Context, *RoutesInfo) (*CheckResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckRoutes not implemented")
}
func (UnimplementedPageServer) mustEmbedUnimplementedPageServer() {}

// UnsafePageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PageServer will
// result in compilation errors.
type UnsafePageServer interface {
	mustEmbedUnimplementedPageServer()
}

func RegisterPageServer(s grpc.ServiceRegistrar, srv PageServer) {
	s.RegisterService(&Page_ServiceDesc, srv)
}

func _Page_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/UserLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).UserLogin(ctx, req.(*AuthInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_UserLogOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).UserLogOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/UserLogOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).UserLogOut(ctx, req.(*UserName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetUserInfo(ctx, req.(*UserName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetUsers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_AddUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).AddUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/AddUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).AddUsers(ctx, req.(*AddUserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_DeleteUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).DeleteUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/DeleteUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).DeleteUsers(ctx, req.(*UserName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_UpdateUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatedUserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).UpdateUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/UpdateUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).UpdateUsers(ctx, req.(*UpdatedUserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_UploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadedFileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).UploadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/UploadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).UploadFile(ctx, req.(*UploadedFileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_UploadFileWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PageServer).UploadFileWithStream(&pageUploadFileWithStreamServer{stream})
}

type Page_UploadFileWithStreamServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*UploadedFileInfo, error)
	grpc.ServerStream
}

type pageUploadFileWithStreamServer struct {
	grpc.ServerStream
}

func (x *pageUploadFileWithStreamServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pageUploadFileWithStreamServer) Recv() (*UploadedFileInfo, error) {
	m := new(UploadedFileInfo)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Page_AddItemsByExcel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).AddItemsByExcel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/AddItemsByExcel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).AddItemsByExcel(ctx, req.(*FileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_ImportHistoryByExcel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HistoryFileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).ImportHistoryByExcel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/ImportHistoryByExcel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).ImportHistoryByExcel(ctx, req.(*HistoryFileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLogsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetLogs(ctx, req.(*QueryLogsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_DeleteLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletedLogInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).DeleteLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/DeleteLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).DeleteLogs(ctx, req.(*DeletedLogInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_DownloadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).DownloadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/DownloadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).DownloadFile(ctx, req.(*FileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetDbInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetDbInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetDbInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetDbInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetDbInfoHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySpeedHistoryDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetDbInfoHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetDbInfoHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetDbInfoHistory(ctx, req.(*QuerySpeedHistoryDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetRoutes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_DeleteRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).DeleteRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/DeleteRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).DeleteRoutes(ctx, req.(*RoutesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_AddRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).AddRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/AddRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).AddRoutes(ctx, req.(*RoutesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_AddUserRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).AddUserRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/AddUserRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).AddUserRoutes(ctx, req.(*RoutesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_DeleteUserRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).DeleteUserRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/DeleteUserRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).DeleteUserRoutes(ctx, req.(*UserName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetAllRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetAllRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetAllRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetAllRoutes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_CheckRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).CheckRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/CheckRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).CheckRoutes(ctx, req.(*RoutesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

// Page_ServiceDesc is the grpc.ServiceDesc for Page service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Page_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.Page",
	HandlerType: (*PageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserLogin",
			Handler:    _Page_UserLogin_Handler,
		},
		{
			MethodName: "UserLogOut",
			Handler:    _Page_UserLogOut_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _Page_GetUserInfo_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _Page_GetUsers_Handler,
		},
		{
			MethodName: "AddUsers",
			Handler:    _Page_AddUsers_Handler,
		},
		{
			MethodName: "DeleteUsers",
			Handler:    _Page_DeleteUsers_Handler,
		},
		{
			MethodName: "UpdateUsers",
			Handler:    _Page_UpdateUsers_Handler,
		},
		{
			MethodName: "UploadFile",
			Handler:    _Page_UploadFile_Handler,
		},
		{
			MethodName: "AddItemsByExcel",
			Handler:    _Page_AddItemsByExcel_Handler,
		},
		{
			MethodName: "ImportHistoryByExcel",
			Handler:    _Page_ImportHistoryByExcel_Handler,
		},
		{
			MethodName: "GetLogs",
			Handler:    _Page_GetLogs_Handler,
		},
		{
			MethodName: "DeleteLogs",
			Handler:    _Page_DeleteLogs_Handler,
		},
		{
			MethodName: "DownloadFile",
			Handler:    _Page_DownloadFile_Handler,
		},
		{
			MethodName: "GetDbInfo",
			Handler:    _Page_GetDbInfo_Handler,
		},
		{
			MethodName: "GetDbInfoHistory",
			Handler:    _Page_GetDbInfoHistory_Handler,
		},
		{
			MethodName: "GetRoutes",
			Handler:    _Page_GetRoutes_Handler,
		},
		{
			MethodName: "DeleteRoutes",
			Handler:    _Page_DeleteRoutes_Handler,
		},
		{
			MethodName: "AddRoutes",
			Handler:    _Page_AddRoutes_Handler,
		},
		{
			MethodName: "AddUserRoutes",
			Handler:    _Page_AddUserRoutes_Handler,
		},
		{
			MethodName: "DeleteUserRoutes",
			Handler:    _Page_DeleteUserRoutes_Handler,
		},
		{
			MethodName: "GetAllRoutes",
			Handler:    _Page_GetAllRoutes_Handler,
		},
		{
			MethodName: "CheckRoutes",
			Handler:    _Page_CheckRoutes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFileWithStream",
			Handler:       _Page_UploadFileWithStream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gdb.proto",
}

// CalcClient is the client API for Calc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CalcClient interface {
	TestCalcItem(ctx context.Context, in *TestCalcItemInfo, opts ...grpc.CallOption) (*TestResult, error)
	AddCalcItem(ctx context.Context, in *AddedCalcItemInfo, opts ...grpc.CallOption) (*CalculationResult, error)
	AddCalcItemWithStream(ctx context.Context, opts ...grpc.CallOption) (Calc_AddCalcItemWithStreamClient, error)
	GetCalcItems(ctx context.Context, in *QueryCalcItemsInfo, opts ...grpc.CallOption) (*CalcItemsInfo, error)
	UpdateCalcItem(ctx context.Context, in *UpdatedCalcInfo, opts ...grpc.CallOption) (*CalculationResult, error)
	StartCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*Rows, error)
	StopCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*Rows, error)
	DeleteCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*Rows, error)
}

type calcClient struct {
	cc grpc.ClientConnInterface
}

func NewCalcClient(cc grpc.ClientConnInterface) CalcClient {
	return &calcClient{cc}
}

func (c *calcClient) TestCalcItem(ctx context.Context, in *TestCalcItemInfo, opts ...grpc.CallOption) (*TestResult, error) {
	out := new(TestResult)
	err := c.cc.Invoke(ctx, "/model.Calc/TestCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) AddCalcItem(ctx context.Context, in *AddedCalcItemInfo, opts ...grpc.CallOption) (*CalculationResult, error) {
	out := new(CalculationResult)
	err := c.cc.Invoke(ctx, "/model.Calc/AddCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) AddCalcItemWithStream(ctx context.Context, opts ...grpc.CallOption) (Calc_AddCalcItemWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Calc_ServiceDesc.Streams[0], "/model.Calc/AddCalcItemWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &calcAddCalcItemWithStreamClient{stream}
	return x, nil
}

type Calc_AddCalcItemWithStreamClient interface {
	Send(*AddedCalcItemInfo) error
	CloseAndRecv() (*CalculationResults, error)
	grpc.ClientStream
}

type calcAddCalcItemWithStreamClient struct {
	grpc.ClientStream
}

func (x *calcAddCalcItemWithStreamClient) Send(m *AddedCalcItemInfo) error {
	return x.ClientStream.SendMsg(m)
}

func (x *calcAddCalcItemWithStreamClient) CloseAndRecv() (*CalculationResults, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CalculationResults)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *calcClient) GetCalcItems(ctx context.Context, in *QueryCalcItemsInfo, opts ...grpc.CallOption) (*CalcItemsInfo, error) {
	out := new(CalcItemsInfo)
	err := c.cc.Invoke(ctx, "/model.Calc/GetCalcItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) UpdateCalcItem(ctx context.Context, in *UpdatedCalcInfo, opts ...grpc.CallOption) (*CalculationResult, error) {
	out := new(CalculationResult)
	err := c.cc.Invoke(ctx, "/model.Calc/UpdateCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) StartCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Calc/StartCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) StopCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Calc/StopCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) DeleteCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*Rows, error) {
	out := new(Rows)
	err := c.cc.Invoke(ctx, "/model.Calc/DeleteCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CalcServer is the server API for Calc service.
// All implementations must embed UnimplementedCalcServer
// for forward compatibility
type CalcServer interface {
	TestCalcItem(context.Context, *TestCalcItemInfo) (*TestResult, error)
	AddCalcItem(context.Context, *AddedCalcItemInfo) (*CalculationResult, error)
	AddCalcItemWithStream(Calc_AddCalcItemWithStreamServer) error
	GetCalcItems(context.Context, *QueryCalcItemsInfo) (*CalcItemsInfo, error)
	UpdateCalcItem(context.Context, *UpdatedCalcInfo) (*CalculationResult, error)
	StartCalcItem(context.Context, *CalcId) (*Rows, error)
	StopCalcItem(context.Context, *CalcId) (*Rows, error)
	DeleteCalcItem(context.Context, *CalcId) (*Rows, error)
	mustEmbedUnimplementedCalcServer()
}

// UnimplementedCalcServer must be embedded to have forward compatible implementations.
type UnimplementedCalcServer struct {
}

func (UnimplementedCalcServer) TestCalcItem(context.Context, *TestCalcItemInfo) (*TestResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestCalcItem not implemented")
}
func (UnimplementedCalcServer) AddCalcItem(context.Context, *AddedCalcItemInfo) (*CalculationResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCalcItem not implemented")
}
func (UnimplementedCalcServer) AddCalcItemWithStream(Calc_AddCalcItemWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method AddCalcItemWithStream not implemented")
}
func (UnimplementedCalcServer) GetCalcItems(context.Context, *QueryCalcItemsInfo) (*CalcItemsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCalcItems not implemented")
}
func (UnimplementedCalcServer) UpdateCalcItem(context.Context, *UpdatedCalcInfo) (*CalculationResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCalcItem not implemented")
}
func (UnimplementedCalcServer) StartCalcItem(context.Context, *CalcId) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartCalcItem not implemented")
}
func (UnimplementedCalcServer) StopCalcItem(context.Context, *CalcId) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopCalcItem not implemented")
}
func (UnimplementedCalcServer) DeleteCalcItem(context.Context, *CalcId) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCalcItem not implemented")
}
func (UnimplementedCalcServer) mustEmbedUnimplementedCalcServer() {}

// UnsafeCalcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CalcServer will
// result in compilation errors.
type UnsafeCalcServer interface {
	mustEmbedUnimplementedCalcServer()
}

func RegisterCalcServer(s grpc.ServiceRegistrar, srv CalcServer) {
	s.RegisterService(&Calc_ServiceDesc, srv)
}

func _Calc_TestCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestCalcItemInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).TestCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/TestCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).TestCalcItem(ctx, req.(*TestCalcItemInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_AddCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddedCalcItemInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).AddCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/AddCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).AddCalcItem(ctx, req.(*AddedCalcItemInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_AddCalcItemWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CalcServer).AddCalcItemWithStream(&calcAddCalcItemWithStreamServer{stream})
}

type Calc_AddCalcItemWithStreamServer interface {
	SendAndClose(*CalculationResults) error
	Recv() (*AddedCalcItemInfo, error)
	grpc.ServerStream
}

type calcAddCalcItemWithStreamServer struct {
	grpc.ServerStream
}

func (x *calcAddCalcItemWithStreamServer) SendAndClose(m *CalculationResults) error {
	return x.ServerStream.SendMsg(m)
}

func (x *calcAddCalcItemWithStreamServer) Recv() (*AddedCalcItemInfo, error) {
	m := new(AddedCalcItemInfo)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Calc_GetCalcItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCalcItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).GetCalcItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/GetCalcItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).GetCalcItems(ctx, req.(*QueryCalcItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_UpdateCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatedCalcInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).UpdateCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/UpdateCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).UpdateCalcItem(ctx, req.(*UpdatedCalcInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_StartCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalcId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).StartCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/StartCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).StartCalcItem(ctx, req.(*CalcId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_StopCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalcId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).StopCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/StopCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).StopCalcItem(ctx, req.(*CalcId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_DeleteCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalcId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).DeleteCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/DeleteCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).DeleteCalcItem(ctx, req.(*CalcId))
	}
	return interceptor(ctx, in, info, handler)
}

// Calc_ServiceDesc is the grpc.ServiceDesc for Calc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Calc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.Calc",
	HandlerType: (*CalcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TestCalcItem",
			Handler:    _Calc_TestCalcItem_Handler,
		},
		{
			MethodName: "AddCalcItem",
			Handler:    _Calc_AddCalcItem_Handler,
		},
		{
			MethodName: "GetCalcItems",
			Handler:    _Calc_GetCalcItems_Handler,
		},
		{
			MethodName: "UpdateCalcItem",
			Handler:    _Calc_UpdateCalcItem_Handler,
		},
		{
			MethodName: "StartCalcItem",
			Handler:    _Calc_StartCalcItem_Handler,
		},
		{
			MethodName: "StopCalcItem",
			Handler:    _Calc_StopCalcItem_Handler,
		},
		{
			MethodName: "DeleteCalcItem",
			Handler:    _Calc_DeleteCalcItem_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AddCalcItemWithStream",
			Handler:       _Calc_AddCalcItemWithStream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gdb.proto",
}
