// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package model

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GroupClient is the client API for Group service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GroupClient interface {
	AddGroups(ctx context.Context, in *AddedGroupInfos, opts ...grpc.CallOption) (*TimeRows, error)
	DeleteGroups(ctx context.Context, in *GroupNamesInfo, opts ...grpc.CallOption) (*TimeRows, error)
	GetGroups(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GroupNamesInfo, error)
	GetGroupProperty(ctx context.Context, in *QueryGroupPropertyInfo, opts ...grpc.CallOption) (*GroupPropertyInfo, error)
	UpdateGroupNames(ctx context.Context, in *UpdatedGroupNamesInfo, opts ...grpc.CallOption) (*TimeRows, error)
	UpdateGroupColumnNames(ctx context.Context, in *UpdatedGroupColumnNamesInfo, opts ...grpc.CallOption) (*TimeCols, error)
	DeleteGroupColumns(ctx context.Context, in *DeletedGroupColumnNamesInfo, opts ...grpc.CallOption) (*TimeCols, error)
	AddGroupColumns(ctx context.Context, in *AddedGroupColumnsInfo, opts ...grpc.CallOption) (*TimeCols, error)
}

type groupClient struct {
	cc grpc.ClientConnInterface
}

func NewGroupClient(cc grpc.ClientConnInterface) GroupClient {
	return &groupClient{cc}
}

func (c *groupClient) AddGroups(ctx context.Context, in *AddedGroupInfos, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Group/AddGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) DeleteGroups(ctx context.Context, in *GroupNamesInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Group/DeleteGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) GetGroups(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GroupNamesInfo, error) {
	out := new(GroupNamesInfo)
	err := c.cc.Invoke(ctx, "/model.Group/GetGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) GetGroupProperty(ctx context.Context, in *QueryGroupPropertyInfo, opts ...grpc.CallOption) (*GroupPropertyInfo, error) {
	out := new(GroupPropertyInfo)
	err := c.cc.Invoke(ctx, "/model.Group/GetGroupProperty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) UpdateGroupNames(ctx context.Context, in *UpdatedGroupNamesInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Group/UpdateGroupNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) UpdateGroupColumnNames(ctx context.Context, in *UpdatedGroupColumnNamesInfo, opts ...grpc.CallOption) (*TimeCols, error) {
	out := new(TimeCols)
	err := c.cc.Invoke(ctx, "/model.Group/UpdateGroupColumnNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) DeleteGroupColumns(ctx context.Context, in *DeletedGroupColumnNamesInfo, opts ...grpc.CallOption) (*TimeCols, error) {
	out := new(TimeCols)
	err := c.cc.Invoke(ctx, "/model.Group/DeleteGroupColumns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupClient) AddGroupColumns(ctx context.Context, in *AddedGroupColumnsInfo, opts ...grpc.CallOption) (*TimeCols, error) {
	out := new(TimeCols)
	err := c.cc.Invoke(ctx, "/model.Group/AddGroupColumns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroupServer is the server API for Group service.
// All implementations must embed UnimplementedGroupServer
// for forward compatibility
type GroupServer interface {
	AddGroups(context.Context, *AddedGroupInfos) (*TimeRows, error)
	DeleteGroups(context.Context, *GroupNamesInfo) (*TimeRows, error)
	GetGroups(context.Context, *emptypb.Empty) (*GroupNamesInfo, error)
	GetGroupProperty(context.Context, *QueryGroupPropertyInfo) (*GroupPropertyInfo, error)
	UpdateGroupNames(context.Context, *UpdatedGroupNamesInfo) (*TimeRows, error)
	UpdateGroupColumnNames(context.Context, *UpdatedGroupColumnNamesInfo) (*TimeCols, error)
	DeleteGroupColumns(context.Context, *DeletedGroupColumnNamesInfo) (*TimeCols, error)
	AddGroupColumns(context.Context, *AddedGroupColumnsInfo) (*TimeCols, error)
	mustEmbedUnimplementedGroupServer()
}

// UnimplementedGroupServer must be embedded to have forward compatible implementations.
type UnimplementedGroupServer struct {
}

func (UnimplementedGroupServer) AddGroups(context.Context, *AddedGroupInfos) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGroups not implemented")
}
func (UnimplementedGroupServer) DeleteGroups(context.Context, *GroupNamesInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroups not implemented")
}
func (UnimplementedGroupServer) GetGroups(context.Context, *emptypb.Empty) (*GroupNamesInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroups not implemented")
}
func (UnimplementedGroupServer) GetGroupProperty(context.Context, *QueryGroupPropertyInfo) (*GroupPropertyInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroupProperty not implemented")
}
func (UnimplementedGroupServer) UpdateGroupNames(context.Context, *UpdatedGroupNamesInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroupNames not implemented")
}
func (UnimplementedGroupServer) UpdateGroupColumnNames(context.Context, *UpdatedGroupColumnNamesInfo) (*TimeCols, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroupColumnNames not implemented")
}
func (UnimplementedGroupServer) DeleteGroupColumns(context.Context, *DeletedGroupColumnNamesInfo) (*TimeCols, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroupColumns not implemented")
}
func (UnimplementedGroupServer) AddGroupColumns(context.Context, *AddedGroupColumnsInfo) (*TimeCols, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGroupColumns not implemented")
}
func (UnimplementedGroupServer) mustEmbedUnimplementedGroupServer() {}

// UnsafeGroupServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroupServer will
// result in compilation errors.
type UnsafeGroupServer interface {
	mustEmbedUnimplementedGroupServer()
}

func RegisterGroupServer(s grpc.ServiceRegistrar, srv GroupServer) {
	s.RegisterService(&Group_ServiceDesc, srv)
}

func _Group_AddGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddedGroupInfos)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).AddGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/AddGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).AddGroups(ctx, req.(*AddedGroupInfos))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_DeleteGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupNamesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).DeleteGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/DeleteGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).DeleteGroups(ctx, req.(*GroupNamesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_GetGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).GetGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/GetGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).GetGroups(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_GetGroupProperty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupPropertyInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).GetGroupProperty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/GetGroupProperty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).GetGroupProperty(ctx, req.(*QueryGroupPropertyInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_UpdateGroupNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatedGroupNamesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).UpdateGroupNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/UpdateGroupNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).UpdateGroupNames(ctx, req.(*UpdatedGroupNamesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_UpdateGroupColumnNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatedGroupColumnNamesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).UpdateGroupColumnNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/UpdateGroupColumnNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).UpdateGroupColumnNames(ctx, req.(*UpdatedGroupColumnNamesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_DeleteGroupColumns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletedGroupColumnNamesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).DeleteGroupColumns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/DeleteGroupColumns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).DeleteGroupColumns(ctx, req.(*DeletedGroupColumnNamesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Group_AddGroupColumns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddedGroupColumnsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServer).AddGroupColumns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Group/AddGroupColumns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServer).AddGroupColumns(ctx, req.(*AddedGroupColumnsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

// Group_ServiceDesc is the grpc.ServiceDesc for Group service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Group_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.Group",
	HandlerType: (*GroupServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddGroups",
			Handler:    _Group_AddGroups_Handler,
		},
		{
			MethodName: "DeleteGroups",
			Handler:    _Group_DeleteGroups_Handler,
		},
		{
			MethodName: "GetGroups",
			Handler:    _Group_GetGroups_Handler,
		},
		{
			MethodName: "GetGroupProperty",
			Handler:    _Group_GetGroupProperty_Handler,
		},
		{
			MethodName: "UpdateGroupNames",
			Handler:    _Group_UpdateGroupNames_Handler,
		},
		{
			MethodName: "UpdateGroupColumnNames",
			Handler:    _Group_UpdateGroupColumnNames_Handler,
		},
		{
			MethodName: "DeleteGroupColumns",
			Handler:    _Group_DeleteGroupColumns_Handler,
		},
		{
			MethodName: "AddGroupColumns",
			Handler:    _Group_AddGroupColumns_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gdb.proto",
}

// ItemClient is the client API for Item service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ItemClient interface {
	AddItems(ctx context.Context, in *AddedItemsInfo, opts ...grpc.CallOption) (*TimeRows, error)
	DeleteItems(ctx context.Context, in *DeletedItemsInfo, opts ...grpc.CallOption) (*TimeRows, error)
	GetItemsWithCount(ctx context.Context, in *ItemsInfo, opts ...grpc.CallOption) (*GdbItemsWithCount, error)
	UpdateItems(ctx context.Context, in *UpdatedItemsInfo, opts ...grpc.CallOption) (*TimeRows, error)
	CheckItems(ctx context.Context, in *CheckItemsInfo, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CleanGroupItems(ctx context.Context, in *GroupNamesInfo, opts ...grpc.CallOption) (*TimeRows, error)
}

type itemClient struct {
	cc grpc.ClientConnInterface
}

func NewItemClient(cc grpc.ClientConnInterface) ItemClient {
	return &itemClient{cc}
}

func (c *itemClient) AddItems(ctx context.Context, in *AddedItemsInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Item/AddItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) DeleteItems(ctx context.Context, in *DeletedItemsInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Item/DeleteItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) GetItemsWithCount(ctx context.Context, in *ItemsInfo, opts ...grpc.CallOption) (*GdbItemsWithCount, error) {
	out := new(GdbItemsWithCount)
	err := c.cc.Invoke(ctx, "/model.Item/GetItemsWithCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) UpdateItems(ctx context.Context, in *UpdatedItemsInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Item/UpdateItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) CheckItems(ctx context.Context, in *CheckItemsInfo, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/model.Item/CheckItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) CleanGroupItems(ctx context.Context, in *GroupNamesInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Item/CleanGroupItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ItemServer is the server API for Item service.
// All implementations must embed UnimplementedItemServer
// for forward compatibility
type ItemServer interface {
	AddItems(context.Context, *AddedItemsInfo) (*TimeRows, error)
	DeleteItems(context.Context, *DeletedItemsInfo) (*TimeRows, error)
	GetItemsWithCount(context.Context, *ItemsInfo) (*GdbItemsWithCount, error)
	UpdateItems(context.Context, *UpdatedItemsInfo) (*TimeRows, error)
	CheckItems(context.Context, *CheckItemsInfo) (*emptypb.Empty, error)
	CleanGroupItems(context.Context, *GroupNamesInfo) (*TimeRows, error)
	mustEmbedUnimplementedItemServer()
}

// UnimplementedItemServer must be embedded to have forward compatible implementations.
type UnimplementedItemServer struct {
}

func (UnimplementedItemServer) AddItems(context.Context, *AddedItemsInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddItems not implemented")
}
func (UnimplementedItemServer) DeleteItems(context.Context, *DeletedItemsInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteItems not implemented")
}
func (UnimplementedItemServer) GetItemsWithCount(context.Context, *ItemsInfo) (*GdbItemsWithCount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetItemsWithCount not implemented")
}
func (UnimplementedItemServer) UpdateItems(context.Context, *UpdatedItemsInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateItems not implemented")
}
func (UnimplementedItemServer) CheckItems(context.Context, *CheckItemsInfo) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckItems not implemented")
}
func (UnimplementedItemServer) CleanGroupItems(context.Context, *GroupNamesInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanGroupItems not implemented")
}
func (UnimplementedItemServer) mustEmbedUnimplementedItemServer() {}

// UnsafeItemServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ItemServer will
// result in compilation errors.
type UnsafeItemServer interface {
	mustEmbedUnimplementedItemServer()
}

func RegisterItemServer(s grpc.ServiceRegistrar, srv ItemServer) {
	s.RegisterService(&Item_ServiceDesc, srv)
}

func _Item_AddItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddedItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).AddItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/AddItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).AddItems(ctx, req.(*AddedItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_DeleteItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletedItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).DeleteItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/DeleteItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).DeleteItems(ctx, req.(*DeletedItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_GetItemsWithCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).GetItemsWithCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/GetItemsWithCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).GetItemsWithCount(ctx, req.(*ItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_UpdateItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatedItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).UpdateItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/UpdateItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).UpdateItems(ctx, req.(*UpdatedItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_CheckItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).CheckItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/CheckItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).CheckItems(ctx, req.(*CheckItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_CleanGroupItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupNamesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).CleanGroupItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Item/CleanGroupItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).CleanGroupItems(ctx, req.(*GroupNamesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

// Item_ServiceDesc is the grpc.ServiceDesc for Item service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Item_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.Item",
	HandlerType: (*ItemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddItems",
			Handler:    _Item_AddItems_Handler,
		},
		{
			MethodName: "DeleteItems",
			Handler:    _Item_DeleteItems_Handler,
		},
		{
			MethodName: "GetItemsWithCount",
			Handler:    _Item_GetItemsWithCount_Handler,
		},
		{
			MethodName: "UpdateItems",
			Handler:    _Item_UpdateItems_Handler,
		},
		{
			MethodName: "CheckItems",
			Handler:    _Item_CheckItems_Handler,
		},
		{
			MethodName: "CleanGroupItems",
			Handler:    _Item_CleanGroupItems_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gdb.proto",
}

// DataClient is the client API for Data service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataClient interface {
	BatchWriteFloatData(ctx context.Context, in *FloatItemValues, opts ...grpc.CallOption) (*TimeRows, error)
	BatchWriteFloatDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteFloatDataWithStreamClient, error)
	BatchWriteIntData(ctx context.Context, in *IntItemValues, opts ...grpc.CallOption) (*TimeRows, error)
	BatchWriteIntDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteIntDataWithStreamClient, error)
	BatchWriteStringData(ctx context.Context, in *StringItemValues, opts ...grpc.CallOption) (*TimeRows, error)
	BatchWriteStringDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteStringDataWithStreamClient, error)
	BatchWriteBoolData(ctx context.Context, in *BoolItemValues, opts ...grpc.CallOption) (*TimeRows, error)
	BatchWriteBoolDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteBoolDataWithStreamClient, error)
	BatchWriteFloatHistoricalData(ctx context.Context, in *FloatHItemValues, opts ...grpc.CallOption) (*TimeRows, error)
	BatchWriteFloatHistoricalDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteFloatHistoricalDataWithStreamClient, error)
	BatchWriteIntHistoricalData(ctx context.Context, in *IntHItemValues, opts ...grpc.CallOption) (*TimeRows, error)
	BatchWriteIntHistoricalDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteIntHistoricalDataWithStreamClient, error)
	BatchWriteStringHistoricalData(ctx context.Context, in *StringHItemValues, opts ...grpc.CallOption) (*TimeRows, error)
	BatchWriteStringHistoricalDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteStringHistoricalDataWithStreamClient, error)
	BatchWriteBoolHistoricalData(ctx context.Context, in *BoolHItemValues, opts ...grpc.CallOption) (*TimeRows, error)
	BatchWriteBoolHistoricalDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteBoolHistoricalDataWithStreamClient, error)
	GetRealTimeData(ctx context.Context, in *QueryRealTimeDataString, opts ...grpc.CallOption) (*GdbRealTimeData, error)
	GetFloatHistoricalData(ctx context.Context, in *QueryHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetIntHistoricalData(ctx context.Context, in *QueryHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetStringHistoricalData(ctx context.Context, in *QueryHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetBoolHistoricalData(ctx context.Context, in *QueryHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetFloatRawHistoricalData(ctx context.Context, in *QueryRawHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetIntRawHistoricalData(ctx context.Context, in *QueryRawHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetStringRawHistoricalData(ctx context.Context, in *QueryRawHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetBoolRawHistoricalData(ctx context.Context, in *QueryRawHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetFloatHistoricalDataWithStamp(ctx context.Context, in *QueryHistoricalDataWithStampString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetIntHistoricalDataWithStamp(ctx context.Context, in *QueryHistoricalDataWithStampString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetStringHistoricalDataWithStamp(ctx context.Context, in *QueryHistoricalDataWithStampString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetBoolHistoricalDataWithStamp(ctx context.Context, in *QueryHistoricalDataWithStampString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetFloatHistoricalDataWithCondition(ctx context.Context, in *QueryHistoricalDataWithConditionString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetIntHistoricalDataWithCondition(ctx context.Context, in *QueryHistoricalDataWithConditionString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetStringHistoricalDataWithCondition(ctx context.Context, in *QueryHistoricalDataWithConditionString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetBoolHistoricalDataWithCondition(ctx context.Context, in *QueryHistoricalDataWithConditionString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	DeleteFloatHistoricalData(ctx context.Context, in *DeleteHistoricalDataString, opts ...grpc.CallOption) (*TimeRows, error)
	DeleteIntHistoricalData(ctx context.Context, in *DeleteHistoricalDataString, opts ...grpc.CallOption) (*TimeRows, error)
	DeleteStringHistoricalData(ctx context.Context, in *DeleteHistoricalDataString, opts ...grpc.CallOption) (*TimeRows, error)
	DeleteBoolHistoricalData(ctx context.Context, in *DeleteHistoricalDataString, opts ...grpc.CallOption) (*TimeRows, error)
	CleanItemData(ctx context.Context, in *DeletedItemsInfo, opts ...grpc.CallOption) (*TimeRows, error)
	ReLoadDb(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TimeRows, error)
}

type dataClient struct {
	cc grpc.ClientConnInterface
}

func NewDataClient(cc grpc.ClientConnInterface) DataClient {
	return &dataClient{cc}
}

func (c *dataClient) BatchWriteFloatData(ctx context.Context, in *FloatItemValues, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/BatchWriteFloatData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) BatchWriteFloatDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteFloatDataWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Data_ServiceDesc.Streams[0], "/model.Data/BatchWriteFloatDataWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBatchWriteFloatDataWithStreamClient{stream}
	return x, nil
}

type Data_BatchWriteFloatDataWithStreamClient interface {
	Send(*FloatItemValues) error
	CloseAndRecv() (*TimeRows, error)
	grpc.ClientStream
}

type dataBatchWriteFloatDataWithStreamClient struct {
	grpc.ClientStream
}

func (x *dataBatchWriteFloatDataWithStreamClient) Send(m *FloatItemValues) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBatchWriteFloatDataWithStreamClient) CloseAndRecv() (*TimeRows, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TimeRows)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataClient) BatchWriteIntData(ctx context.Context, in *IntItemValues, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/BatchWriteIntData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) BatchWriteIntDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteIntDataWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Data_ServiceDesc.Streams[1], "/model.Data/BatchWriteIntDataWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBatchWriteIntDataWithStreamClient{stream}
	return x, nil
}

type Data_BatchWriteIntDataWithStreamClient interface {
	Send(*IntItemValues) error
	CloseAndRecv() (*TimeRows, error)
	grpc.ClientStream
}

type dataBatchWriteIntDataWithStreamClient struct {
	grpc.ClientStream
}

func (x *dataBatchWriteIntDataWithStreamClient) Send(m *IntItemValues) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBatchWriteIntDataWithStreamClient) CloseAndRecv() (*TimeRows, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TimeRows)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataClient) BatchWriteStringData(ctx context.Context, in *StringItemValues, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/BatchWriteStringData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) BatchWriteStringDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteStringDataWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Data_ServiceDesc.Streams[2], "/model.Data/BatchWriteStringDataWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBatchWriteStringDataWithStreamClient{stream}
	return x, nil
}

type Data_BatchWriteStringDataWithStreamClient interface {
	Send(*StringItemValues) error
	CloseAndRecv() (*TimeRows, error)
	grpc.ClientStream
}

type dataBatchWriteStringDataWithStreamClient struct {
	grpc.ClientStream
}

func (x *dataBatchWriteStringDataWithStreamClient) Send(m *StringItemValues) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBatchWriteStringDataWithStreamClient) CloseAndRecv() (*TimeRows, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TimeRows)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataClient) BatchWriteBoolData(ctx context.Context, in *BoolItemValues, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/BatchWriteBoolData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) BatchWriteBoolDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteBoolDataWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Data_ServiceDesc.Streams[3], "/model.Data/BatchWriteBoolDataWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBatchWriteBoolDataWithStreamClient{stream}
	return x, nil
}

type Data_BatchWriteBoolDataWithStreamClient interface {
	Send(*BoolItemValues) error
	CloseAndRecv() (*TimeRows, error)
	grpc.ClientStream
}

type dataBatchWriteBoolDataWithStreamClient struct {
	grpc.ClientStream
}

func (x *dataBatchWriteBoolDataWithStreamClient) Send(m *BoolItemValues) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBatchWriteBoolDataWithStreamClient) CloseAndRecv() (*TimeRows, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TimeRows)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataClient) BatchWriteFloatHistoricalData(ctx context.Context, in *FloatHItemValues, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/BatchWriteFloatHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) BatchWriteFloatHistoricalDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteFloatHistoricalDataWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Data_ServiceDesc.Streams[4], "/model.Data/BatchWriteFloatHistoricalDataWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBatchWriteFloatHistoricalDataWithStreamClient{stream}
	return x, nil
}

type Data_BatchWriteFloatHistoricalDataWithStreamClient interface {
	Send(*FloatHItemValues) error
	CloseAndRecv() (*TimeRows, error)
	grpc.ClientStream
}

type dataBatchWriteFloatHistoricalDataWithStreamClient struct {
	grpc.ClientStream
}

func (x *dataBatchWriteFloatHistoricalDataWithStreamClient) Send(m *FloatHItemValues) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBatchWriteFloatHistoricalDataWithStreamClient) CloseAndRecv() (*TimeRows, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TimeRows)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataClient) BatchWriteIntHistoricalData(ctx context.Context, in *IntHItemValues, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/BatchWriteIntHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) BatchWriteIntHistoricalDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteIntHistoricalDataWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Data_ServiceDesc.Streams[5], "/model.Data/BatchWriteIntHistoricalDataWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBatchWriteIntHistoricalDataWithStreamClient{stream}
	return x, nil
}

type Data_BatchWriteIntHistoricalDataWithStreamClient interface {
	Send(*IntHItemValues) error
	CloseAndRecv() (*TimeRows, error)
	grpc.ClientStream
}

type dataBatchWriteIntHistoricalDataWithStreamClient struct {
	grpc.ClientStream
}

func (x *dataBatchWriteIntHistoricalDataWithStreamClient) Send(m *IntHItemValues) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBatchWriteIntHistoricalDataWithStreamClient) CloseAndRecv() (*TimeRows, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TimeRows)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataClient) BatchWriteStringHistoricalData(ctx context.Context, in *StringHItemValues, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/BatchWriteStringHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) BatchWriteStringHistoricalDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteStringHistoricalDataWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Data_ServiceDesc.Streams[6], "/model.Data/BatchWriteStringHistoricalDataWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBatchWriteStringHistoricalDataWithStreamClient{stream}
	return x, nil
}

type Data_BatchWriteStringHistoricalDataWithStreamClient interface {
	Send(*StringHItemValues) error
	CloseAndRecv() (*TimeRows, error)
	grpc.ClientStream
}

type dataBatchWriteStringHistoricalDataWithStreamClient struct {
	grpc.ClientStream
}

func (x *dataBatchWriteStringHistoricalDataWithStreamClient) Send(m *StringHItemValues) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBatchWriteStringHistoricalDataWithStreamClient) CloseAndRecv() (*TimeRows, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TimeRows)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataClient) BatchWriteBoolHistoricalData(ctx context.Context, in *BoolHItemValues, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/BatchWriteBoolHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) BatchWriteBoolHistoricalDataWithStream(ctx context.Context, opts ...grpc.CallOption) (Data_BatchWriteBoolHistoricalDataWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Data_ServiceDesc.Streams[7], "/model.Data/BatchWriteBoolHistoricalDataWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataBatchWriteBoolHistoricalDataWithStreamClient{stream}
	return x, nil
}

type Data_BatchWriteBoolHistoricalDataWithStreamClient interface {
	Send(*BoolHItemValues) error
	CloseAndRecv() (*TimeRows, error)
	grpc.ClientStream
}

type dataBatchWriteBoolHistoricalDataWithStreamClient struct {
	grpc.ClientStream
}

func (x *dataBatchWriteBoolHistoricalDataWithStreamClient) Send(m *BoolHItemValues) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataBatchWriteBoolHistoricalDataWithStreamClient) CloseAndRecv() (*TimeRows, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TimeRows)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataClient) GetRealTimeData(ctx context.Context, in *QueryRealTimeDataString, opts ...grpc.CallOption) (*GdbRealTimeData, error) {
	out := new(GdbRealTimeData)
	err := c.cc.Invoke(ctx, "/model.Data/GetRealTimeData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetFloatHistoricalData(ctx context.Context, in *QueryHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetFloatHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetIntHistoricalData(ctx context.Context, in *QueryHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetIntHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetStringHistoricalData(ctx context.Context, in *QueryHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetStringHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetBoolHistoricalData(ctx context.Context, in *QueryHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetBoolHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetFloatRawHistoricalData(ctx context.Context, in *QueryRawHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetFloatRawHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetIntRawHistoricalData(ctx context.Context, in *QueryRawHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetIntRawHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetStringRawHistoricalData(ctx context.Context, in *QueryRawHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetStringRawHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetBoolRawHistoricalData(ctx context.Context, in *QueryRawHistoricalDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetBoolRawHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetFloatHistoricalDataWithStamp(ctx context.Context, in *QueryHistoricalDataWithStampString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetFloatHistoricalDataWithStamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetIntHistoricalDataWithStamp(ctx context.Context, in *QueryHistoricalDataWithStampString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetIntHistoricalDataWithStamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetStringHistoricalDataWithStamp(ctx context.Context, in *QueryHistoricalDataWithStampString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetStringHistoricalDataWithStamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetBoolHistoricalDataWithStamp(ctx context.Context, in *QueryHistoricalDataWithStampString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetBoolHistoricalDataWithStamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetFloatHistoricalDataWithCondition(ctx context.Context, in *QueryHistoricalDataWithConditionString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetFloatHistoricalDataWithCondition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetIntHistoricalDataWithCondition(ctx context.Context, in *QueryHistoricalDataWithConditionString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetIntHistoricalDataWithCondition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetStringHistoricalDataWithCondition(ctx context.Context, in *QueryHistoricalDataWithConditionString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetStringHistoricalDataWithCondition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) GetBoolHistoricalDataWithCondition(ctx context.Context, in *QueryHistoricalDataWithConditionString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Data/GetBoolHistoricalDataWithCondition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) DeleteFloatHistoricalData(ctx context.Context, in *DeleteHistoricalDataString, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/DeleteFloatHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) DeleteIntHistoricalData(ctx context.Context, in *DeleteHistoricalDataString, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/DeleteIntHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) DeleteStringHistoricalData(ctx context.Context, in *DeleteHistoricalDataString, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/DeleteStringHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) DeleteBoolHistoricalData(ctx context.Context, in *DeleteHistoricalDataString, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/DeleteBoolHistoricalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) CleanItemData(ctx context.Context, in *DeletedItemsInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/CleanItemData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataClient) ReLoadDb(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Data/ReLoadDb", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataServer is the server API for Data service.
// All implementations must embed UnimplementedDataServer
// for forward compatibility
type DataServer interface {
	BatchWriteFloatData(context.Context, *FloatItemValues) (*TimeRows, error)
	BatchWriteFloatDataWithStream(Data_BatchWriteFloatDataWithStreamServer) error
	BatchWriteIntData(context.Context, *IntItemValues) (*TimeRows, error)
	BatchWriteIntDataWithStream(Data_BatchWriteIntDataWithStreamServer) error
	BatchWriteStringData(context.Context, *StringItemValues) (*TimeRows, error)
	BatchWriteStringDataWithStream(Data_BatchWriteStringDataWithStreamServer) error
	BatchWriteBoolData(context.Context, *BoolItemValues) (*TimeRows, error)
	BatchWriteBoolDataWithStream(Data_BatchWriteBoolDataWithStreamServer) error
	BatchWriteFloatHistoricalData(context.Context, *FloatHItemValues) (*TimeRows, error)
	BatchWriteFloatHistoricalDataWithStream(Data_BatchWriteFloatHistoricalDataWithStreamServer) error
	BatchWriteIntHistoricalData(context.Context, *IntHItemValues) (*TimeRows, error)
	BatchWriteIntHistoricalDataWithStream(Data_BatchWriteIntHistoricalDataWithStreamServer) error
	BatchWriteStringHistoricalData(context.Context, *StringHItemValues) (*TimeRows, error)
	BatchWriteStringHistoricalDataWithStream(Data_BatchWriteStringHistoricalDataWithStreamServer) error
	BatchWriteBoolHistoricalData(context.Context, *BoolHItemValues) (*TimeRows, error)
	BatchWriteBoolHistoricalDataWithStream(Data_BatchWriteBoolHistoricalDataWithStreamServer) error
	GetRealTimeData(context.Context, *QueryRealTimeDataString) (*GdbRealTimeData, error)
	GetFloatHistoricalData(context.Context, *QueryHistoricalDataString) (*GdbHistoricalData, error)
	GetIntHistoricalData(context.Context, *QueryHistoricalDataString) (*GdbHistoricalData, error)
	GetStringHistoricalData(context.Context, *QueryHistoricalDataString) (*GdbHistoricalData, error)
	GetBoolHistoricalData(context.Context, *QueryHistoricalDataString) (*GdbHistoricalData, error)
	GetFloatRawHistoricalData(context.Context, *QueryRawHistoricalDataString) (*GdbHistoricalData, error)
	GetIntRawHistoricalData(context.Context, *QueryRawHistoricalDataString) (*GdbHistoricalData, error)
	GetStringRawHistoricalData(context.Context, *QueryRawHistoricalDataString) (*GdbHistoricalData, error)
	GetBoolRawHistoricalData(context.Context, *QueryRawHistoricalDataString) (*GdbHistoricalData, error)
	GetFloatHistoricalDataWithStamp(context.Context, *QueryHistoricalDataWithStampString) (*GdbHistoricalData, error)
	GetIntHistoricalDataWithStamp(context.Context, *QueryHistoricalDataWithStampString) (*GdbHistoricalData, error)
	GetStringHistoricalDataWithStamp(context.Context, *QueryHistoricalDataWithStampString) (*GdbHistoricalData, error)
	GetBoolHistoricalDataWithStamp(context.Context, *QueryHistoricalDataWithStampString) (*GdbHistoricalData, error)
	GetFloatHistoricalDataWithCondition(context.Context, *QueryHistoricalDataWithConditionString) (*GdbHistoricalData, error)
	GetIntHistoricalDataWithCondition(context.Context, *QueryHistoricalDataWithConditionString) (*GdbHistoricalData, error)
	GetStringHistoricalDataWithCondition(context.Context, *QueryHistoricalDataWithConditionString) (*GdbHistoricalData, error)
	GetBoolHistoricalDataWithCondition(context.Context, *QueryHistoricalDataWithConditionString) (*GdbHistoricalData, error)
	DeleteFloatHistoricalData(context.Context, *DeleteHistoricalDataString) (*TimeRows, error)
	DeleteIntHistoricalData(context.Context, *DeleteHistoricalDataString) (*TimeRows, error)
	DeleteStringHistoricalData(context.Context, *DeleteHistoricalDataString) (*TimeRows, error)
	DeleteBoolHistoricalData(context.Context, *DeleteHistoricalDataString) (*TimeRows, error)
	CleanItemData(context.Context, *DeletedItemsInfo) (*TimeRows, error)
	ReLoadDb(context.Context, *emptypb.Empty) (*TimeRows, error)
	mustEmbedUnimplementedDataServer()
}

// UnimplementedDataServer must be embedded to have forward compatible implementations.
type UnimplementedDataServer struct {
}

func (UnimplementedDataServer) BatchWriteFloatData(context.Context, *FloatItemValues) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchWriteFloatData not implemented")
}
func (UnimplementedDataServer) BatchWriteFloatDataWithStream(Data_BatchWriteFloatDataWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchWriteFloatDataWithStream not implemented")
}
func (UnimplementedDataServer) BatchWriteIntData(context.Context, *IntItemValues) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchWriteIntData not implemented")
}
func (UnimplementedDataServer) BatchWriteIntDataWithStream(Data_BatchWriteIntDataWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchWriteIntDataWithStream not implemented")
}
func (UnimplementedDataServer) BatchWriteStringData(context.Context, *StringItemValues) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchWriteStringData not implemented")
}
func (UnimplementedDataServer) BatchWriteStringDataWithStream(Data_BatchWriteStringDataWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchWriteStringDataWithStream not implemented")
}
func (UnimplementedDataServer) BatchWriteBoolData(context.Context, *BoolItemValues) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchWriteBoolData not implemented")
}
func (UnimplementedDataServer) BatchWriteBoolDataWithStream(Data_BatchWriteBoolDataWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchWriteBoolDataWithStream not implemented")
}
func (UnimplementedDataServer) BatchWriteFloatHistoricalData(context.Context, *FloatHItemValues) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchWriteFloatHistoricalData not implemented")
}
func (UnimplementedDataServer) BatchWriteFloatHistoricalDataWithStream(Data_BatchWriteFloatHistoricalDataWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchWriteFloatHistoricalDataWithStream not implemented")
}
func (UnimplementedDataServer) BatchWriteIntHistoricalData(context.Context, *IntHItemValues) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchWriteIntHistoricalData not implemented")
}
func (UnimplementedDataServer) BatchWriteIntHistoricalDataWithStream(Data_BatchWriteIntHistoricalDataWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchWriteIntHistoricalDataWithStream not implemented")
}
func (UnimplementedDataServer) BatchWriteStringHistoricalData(context.Context, *StringHItemValues) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchWriteStringHistoricalData not implemented")
}
func (UnimplementedDataServer) BatchWriteStringHistoricalDataWithStream(Data_BatchWriteStringHistoricalDataWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchWriteStringHistoricalDataWithStream not implemented")
}
func (UnimplementedDataServer) BatchWriteBoolHistoricalData(context.Context, *BoolHItemValues) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchWriteBoolHistoricalData not implemented")
}
func (UnimplementedDataServer) BatchWriteBoolHistoricalDataWithStream(Data_BatchWriteBoolHistoricalDataWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchWriteBoolHistoricalDataWithStream not implemented")
}
func (UnimplementedDataServer) GetRealTimeData(context.Context, *QueryRealTimeDataString) (*GdbRealTimeData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRealTimeData not implemented")
}
func (UnimplementedDataServer) GetFloatHistoricalData(context.Context, *QueryHistoricalDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFloatHistoricalData not implemented")
}
func (UnimplementedDataServer) GetIntHistoricalData(context.Context, *QueryHistoricalDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntHistoricalData not implemented")
}
func (UnimplementedDataServer) GetStringHistoricalData(context.Context, *QueryHistoricalDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStringHistoricalData not implemented")
}
func (UnimplementedDataServer) GetBoolHistoricalData(context.Context, *QueryHistoricalDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBoolHistoricalData not implemented")
}
func (UnimplementedDataServer) GetFloatRawHistoricalData(context.Context, *QueryRawHistoricalDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFloatRawHistoricalData not implemented")
}
func (UnimplementedDataServer) GetIntRawHistoricalData(context.Context, *QueryRawHistoricalDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntRawHistoricalData not implemented")
}
func (UnimplementedDataServer) GetStringRawHistoricalData(context.Context, *QueryRawHistoricalDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStringRawHistoricalData not implemented")
}
func (UnimplementedDataServer) GetBoolRawHistoricalData(context.Context, *QueryRawHistoricalDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBoolRawHistoricalData not implemented")
}
func (UnimplementedDataServer) GetFloatHistoricalDataWithStamp(context.Context, *QueryHistoricalDataWithStampString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFloatHistoricalDataWithStamp not implemented")
}
func (UnimplementedDataServer) GetIntHistoricalDataWithStamp(context.Context, *QueryHistoricalDataWithStampString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntHistoricalDataWithStamp not implemented")
}
func (UnimplementedDataServer) GetStringHistoricalDataWithStamp(context.Context, *QueryHistoricalDataWithStampString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStringHistoricalDataWithStamp not implemented")
}
func (UnimplementedDataServer) GetBoolHistoricalDataWithStamp(context.Context, *QueryHistoricalDataWithStampString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBoolHistoricalDataWithStamp not implemented")
}
func (UnimplementedDataServer) GetFloatHistoricalDataWithCondition(context.Context, *QueryHistoricalDataWithConditionString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFloatHistoricalDataWithCondition not implemented")
}
func (UnimplementedDataServer) GetIntHistoricalDataWithCondition(context.Context, *QueryHistoricalDataWithConditionString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntHistoricalDataWithCondition not implemented")
}
func (UnimplementedDataServer) GetStringHistoricalDataWithCondition(context.Context, *QueryHistoricalDataWithConditionString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStringHistoricalDataWithCondition not implemented")
}
func (UnimplementedDataServer) GetBoolHistoricalDataWithCondition(context.Context, *QueryHistoricalDataWithConditionString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBoolHistoricalDataWithCondition not implemented")
}
func (UnimplementedDataServer) DeleteFloatHistoricalData(context.Context, *DeleteHistoricalDataString) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFloatHistoricalData not implemented")
}
func (UnimplementedDataServer) DeleteIntHistoricalData(context.Context, *DeleteHistoricalDataString) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIntHistoricalData not implemented")
}
func (UnimplementedDataServer) DeleteStringHistoricalData(context.Context, *DeleteHistoricalDataString) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStringHistoricalData not implemented")
}
func (UnimplementedDataServer) DeleteBoolHistoricalData(context.Context, *DeleteHistoricalDataString) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBoolHistoricalData not implemented")
}
func (UnimplementedDataServer) CleanItemData(context.Context, *DeletedItemsInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanItemData not implemented")
}
func (UnimplementedDataServer) ReLoadDb(context.Context, *emptypb.Empty) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReLoadDb not implemented")
}
func (UnimplementedDataServer) mustEmbedUnimplementedDataServer() {}

// UnsafeDataServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataServer will
// result in compilation errors.
type UnsafeDataServer interface {
	mustEmbedUnimplementedDataServer()
}

func RegisterDataServer(s grpc.ServiceRegistrar, srv DataServer) {
	s.RegisterService(&Data_ServiceDesc, srv)
}

func _Data_BatchWriteFloatData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FloatItemValues)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).BatchWriteFloatData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/BatchWriteFloatData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).BatchWriteFloatData(ctx, req.(*FloatItemValues))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_BatchWriteFloatDataWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServer).BatchWriteFloatDataWithStream(&dataBatchWriteFloatDataWithStreamServer{stream})
}

type Data_BatchWriteFloatDataWithStreamServer interface {
	SendAndClose(*TimeRows) error
	Recv() (*FloatItemValues, error)
	grpc.ServerStream
}

type dataBatchWriteFloatDataWithStreamServer struct {
	grpc.ServerStream
}

func (x *dataBatchWriteFloatDataWithStreamServer) SendAndClose(m *TimeRows) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBatchWriteFloatDataWithStreamServer) Recv() (*FloatItemValues, error) {
	m := new(FloatItemValues)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Data_BatchWriteIntData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntItemValues)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).BatchWriteIntData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/BatchWriteIntData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).BatchWriteIntData(ctx, req.(*IntItemValues))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_BatchWriteIntDataWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServer).BatchWriteIntDataWithStream(&dataBatchWriteIntDataWithStreamServer{stream})
}

type Data_BatchWriteIntDataWithStreamServer interface {
	SendAndClose(*TimeRows) error
	Recv() (*IntItemValues, error)
	grpc.ServerStream
}

type dataBatchWriteIntDataWithStreamServer struct {
	grpc.ServerStream
}

func (x *dataBatchWriteIntDataWithStreamServer) SendAndClose(m *TimeRows) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBatchWriteIntDataWithStreamServer) Recv() (*IntItemValues, error) {
	m := new(IntItemValues)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Data_BatchWriteStringData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringItemValues)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).BatchWriteStringData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/BatchWriteStringData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).BatchWriteStringData(ctx, req.(*StringItemValues))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_BatchWriteStringDataWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServer).BatchWriteStringDataWithStream(&dataBatchWriteStringDataWithStreamServer{stream})
}

type Data_BatchWriteStringDataWithStreamServer interface {
	SendAndClose(*TimeRows) error
	Recv() (*StringItemValues, error)
	grpc.ServerStream
}

type dataBatchWriteStringDataWithStreamServer struct {
	grpc.ServerStream
}

func (x *dataBatchWriteStringDataWithStreamServer) SendAndClose(m *TimeRows) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBatchWriteStringDataWithStreamServer) Recv() (*StringItemValues, error) {
	m := new(StringItemValues)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Data_BatchWriteBoolData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoolItemValues)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).BatchWriteBoolData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/BatchWriteBoolData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).BatchWriteBoolData(ctx, req.(*BoolItemValues))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_BatchWriteBoolDataWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServer).BatchWriteBoolDataWithStream(&dataBatchWriteBoolDataWithStreamServer{stream})
}

type Data_BatchWriteBoolDataWithStreamServer interface {
	SendAndClose(*TimeRows) error
	Recv() (*BoolItemValues, error)
	grpc.ServerStream
}

type dataBatchWriteBoolDataWithStreamServer struct {
	grpc.ServerStream
}

func (x *dataBatchWriteBoolDataWithStreamServer) SendAndClose(m *TimeRows) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBatchWriteBoolDataWithStreamServer) Recv() (*BoolItemValues, error) {
	m := new(BoolItemValues)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Data_BatchWriteFloatHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FloatHItemValues)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).BatchWriteFloatHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/BatchWriteFloatHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).BatchWriteFloatHistoricalData(ctx, req.(*FloatHItemValues))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_BatchWriteFloatHistoricalDataWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServer).BatchWriteFloatHistoricalDataWithStream(&dataBatchWriteFloatHistoricalDataWithStreamServer{stream})
}

type Data_BatchWriteFloatHistoricalDataWithStreamServer interface {
	SendAndClose(*TimeRows) error
	Recv() (*FloatHItemValues, error)
	grpc.ServerStream
}

type dataBatchWriteFloatHistoricalDataWithStreamServer struct {
	grpc.ServerStream
}

func (x *dataBatchWriteFloatHistoricalDataWithStreamServer) SendAndClose(m *TimeRows) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBatchWriteFloatHistoricalDataWithStreamServer) Recv() (*FloatHItemValues, error) {
	m := new(FloatHItemValues)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Data_BatchWriteIntHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntHItemValues)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).BatchWriteIntHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/BatchWriteIntHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).BatchWriteIntHistoricalData(ctx, req.(*IntHItemValues))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_BatchWriteIntHistoricalDataWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServer).BatchWriteIntHistoricalDataWithStream(&dataBatchWriteIntHistoricalDataWithStreamServer{stream})
}

type Data_BatchWriteIntHistoricalDataWithStreamServer interface {
	SendAndClose(*TimeRows) error
	Recv() (*IntHItemValues, error)
	grpc.ServerStream
}

type dataBatchWriteIntHistoricalDataWithStreamServer struct {
	grpc.ServerStream
}

func (x *dataBatchWriteIntHistoricalDataWithStreamServer) SendAndClose(m *TimeRows) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBatchWriteIntHistoricalDataWithStreamServer) Recv() (*IntHItemValues, error) {
	m := new(IntHItemValues)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Data_BatchWriteStringHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringHItemValues)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).BatchWriteStringHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/BatchWriteStringHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).BatchWriteStringHistoricalData(ctx, req.(*StringHItemValues))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_BatchWriteStringHistoricalDataWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServer).BatchWriteStringHistoricalDataWithStream(&dataBatchWriteStringHistoricalDataWithStreamServer{stream})
}

type Data_BatchWriteStringHistoricalDataWithStreamServer interface {
	SendAndClose(*TimeRows) error
	Recv() (*StringHItemValues, error)
	grpc.ServerStream
}

type dataBatchWriteStringHistoricalDataWithStreamServer struct {
	grpc.ServerStream
}

func (x *dataBatchWriteStringHistoricalDataWithStreamServer) SendAndClose(m *TimeRows) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBatchWriteStringHistoricalDataWithStreamServer) Recv() (*StringHItemValues, error) {
	m := new(StringHItemValues)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Data_BatchWriteBoolHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoolHItemValues)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).BatchWriteBoolHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/BatchWriteBoolHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).BatchWriteBoolHistoricalData(ctx, req.(*BoolHItemValues))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_BatchWriteBoolHistoricalDataWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServer).BatchWriteBoolHistoricalDataWithStream(&dataBatchWriteBoolHistoricalDataWithStreamServer{stream})
}

type Data_BatchWriteBoolHistoricalDataWithStreamServer interface {
	SendAndClose(*TimeRows) error
	Recv() (*BoolHItemValues, error)
	grpc.ServerStream
}

type dataBatchWriteBoolHistoricalDataWithStreamServer struct {
	grpc.ServerStream
}

func (x *dataBatchWriteBoolHistoricalDataWithStreamServer) SendAndClose(m *TimeRows) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataBatchWriteBoolHistoricalDataWithStreamServer) Recv() (*BoolHItemValues, error) {
	m := new(BoolHItemValues)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Data_GetRealTimeData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRealTimeDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetRealTimeData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetRealTimeData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetRealTimeData(ctx, req.(*QueryRealTimeDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetFloatHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetFloatHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetFloatHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetFloatHistoricalData(ctx, req.(*QueryHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetIntHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetIntHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetIntHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetIntHistoricalData(ctx, req.(*QueryHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetStringHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetStringHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetStringHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetStringHistoricalData(ctx, req.(*QueryHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetBoolHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetBoolHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetBoolHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetBoolHistoricalData(ctx, req.(*QueryHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetFloatRawHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRawHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetFloatRawHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetFloatRawHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetFloatRawHistoricalData(ctx, req.(*QueryRawHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetIntRawHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRawHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetIntRawHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetIntRawHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetIntRawHistoricalData(ctx, req.(*QueryRawHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetStringRawHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRawHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetStringRawHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetStringRawHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetStringRawHistoricalData(ctx, req.(*QueryRawHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetBoolRawHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRawHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetBoolRawHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetBoolRawHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetBoolRawHistoricalData(ctx, req.(*QueryRawHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetFloatHistoricalDataWithStamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataWithStampString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetFloatHistoricalDataWithStamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetFloatHistoricalDataWithStamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetFloatHistoricalDataWithStamp(ctx, req.(*QueryHistoricalDataWithStampString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetIntHistoricalDataWithStamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataWithStampString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetIntHistoricalDataWithStamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetIntHistoricalDataWithStamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetIntHistoricalDataWithStamp(ctx, req.(*QueryHistoricalDataWithStampString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetStringHistoricalDataWithStamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataWithStampString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetStringHistoricalDataWithStamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetStringHistoricalDataWithStamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetStringHistoricalDataWithStamp(ctx, req.(*QueryHistoricalDataWithStampString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetBoolHistoricalDataWithStamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataWithStampString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetBoolHistoricalDataWithStamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetBoolHistoricalDataWithStamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetBoolHistoricalDataWithStamp(ctx, req.(*QueryHistoricalDataWithStampString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetFloatHistoricalDataWithCondition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataWithConditionString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetFloatHistoricalDataWithCondition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetFloatHistoricalDataWithCondition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetFloatHistoricalDataWithCondition(ctx, req.(*QueryHistoricalDataWithConditionString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetIntHistoricalDataWithCondition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataWithConditionString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetIntHistoricalDataWithCondition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetIntHistoricalDataWithCondition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetIntHistoricalDataWithCondition(ctx, req.(*QueryHistoricalDataWithConditionString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetStringHistoricalDataWithCondition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataWithConditionString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetStringHistoricalDataWithCondition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetStringHistoricalDataWithCondition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetStringHistoricalDataWithCondition(ctx, req.(*QueryHistoricalDataWithConditionString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_GetBoolHistoricalDataWithCondition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoricalDataWithConditionString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).GetBoolHistoricalDataWithCondition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/GetBoolHistoricalDataWithCondition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).GetBoolHistoricalDataWithCondition(ctx, req.(*QueryHistoricalDataWithConditionString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_DeleteFloatHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).DeleteFloatHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/DeleteFloatHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).DeleteFloatHistoricalData(ctx, req.(*DeleteHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_DeleteIntHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).DeleteIntHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/DeleteIntHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).DeleteIntHistoricalData(ctx, req.(*DeleteHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_DeleteStringHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).DeleteStringHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/DeleteStringHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).DeleteStringHistoricalData(ctx, req.(*DeleteHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_DeleteBoolHistoricalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHistoricalDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).DeleteBoolHistoricalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/DeleteBoolHistoricalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).DeleteBoolHistoricalData(ctx, req.(*DeleteHistoricalDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_CleanItemData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletedItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).CleanItemData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/CleanItemData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).CleanItemData(ctx, req.(*DeletedItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Data_ReLoadDb_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServer).ReLoadDb(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Data/ReLoadDb",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServer).ReLoadDb(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Data_ServiceDesc is the grpc.ServiceDesc for Data service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Data_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.Data",
	HandlerType: (*DataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BatchWriteFloatData",
			Handler:    _Data_BatchWriteFloatData_Handler,
		},
		{
			MethodName: "BatchWriteIntData",
			Handler:    _Data_BatchWriteIntData_Handler,
		},
		{
			MethodName: "BatchWriteStringData",
			Handler:    _Data_BatchWriteStringData_Handler,
		},
		{
			MethodName: "BatchWriteBoolData",
			Handler:    _Data_BatchWriteBoolData_Handler,
		},
		{
			MethodName: "BatchWriteFloatHistoricalData",
			Handler:    _Data_BatchWriteFloatHistoricalData_Handler,
		},
		{
			MethodName: "BatchWriteIntHistoricalData",
			Handler:    _Data_BatchWriteIntHistoricalData_Handler,
		},
		{
			MethodName: "BatchWriteStringHistoricalData",
			Handler:    _Data_BatchWriteStringHistoricalData_Handler,
		},
		{
			MethodName: "BatchWriteBoolHistoricalData",
			Handler:    _Data_BatchWriteBoolHistoricalData_Handler,
		},
		{
			MethodName: "GetRealTimeData",
			Handler:    _Data_GetRealTimeData_Handler,
		},
		{
			MethodName: "GetFloatHistoricalData",
			Handler:    _Data_GetFloatHistoricalData_Handler,
		},
		{
			MethodName: "GetIntHistoricalData",
			Handler:    _Data_GetIntHistoricalData_Handler,
		},
		{
			MethodName: "GetStringHistoricalData",
			Handler:    _Data_GetStringHistoricalData_Handler,
		},
		{
			MethodName: "GetBoolHistoricalData",
			Handler:    _Data_GetBoolHistoricalData_Handler,
		},
		{
			MethodName: "GetFloatRawHistoricalData",
			Handler:    _Data_GetFloatRawHistoricalData_Handler,
		},
		{
			MethodName: "GetIntRawHistoricalData",
			Handler:    _Data_GetIntRawHistoricalData_Handler,
		},
		{
			MethodName: "GetStringRawHistoricalData",
			Handler:    _Data_GetStringRawHistoricalData_Handler,
		},
		{
			MethodName: "GetBoolRawHistoricalData",
			Handler:    _Data_GetBoolRawHistoricalData_Handler,
		},
		{
			MethodName: "GetFloatHistoricalDataWithStamp",
			Handler:    _Data_GetFloatHistoricalDataWithStamp_Handler,
		},
		{
			MethodName: "GetIntHistoricalDataWithStamp",
			Handler:    _Data_GetIntHistoricalDataWithStamp_Handler,
		},
		{
			MethodName: "GetStringHistoricalDataWithStamp",
			Handler:    _Data_GetStringHistoricalDataWithStamp_Handler,
		},
		{
			MethodName: "GetBoolHistoricalDataWithStamp",
			Handler:    _Data_GetBoolHistoricalDataWithStamp_Handler,
		},
		{
			MethodName: "GetFloatHistoricalDataWithCondition",
			Handler:    _Data_GetFloatHistoricalDataWithCondition_Handler,
		},
		{
			MethodName: "GetIntHistoricalDataWithCondition",
			Handler:    _Data_GetIntHistoricalDataWithCondition_Handler,
		},
		{
			MethodName: "GetStringHistoricalDataWithCondition",
			Handler:    _Data_GetStringHistoricalDataWithCondition_Handler,
		},
		{
			MethodName: "GetBoolHistoricalDataWithCondition",
			Handler:    _Data_GetBoolHistoricalDataWithCondition_Handler,
		},
		{
			MethodName: "DeleteFloatHistoricalData",
			Handler:    _Data_DeleteFloatHistoricalData_Handler,
		},
		{
			MethodName: "DeleteIntHistoricalData",
			Handler:    _Data_DeleteIntHistoricalData_Handler,
		},
		{
			MethodName: "DeleteStringHistoricalData",
			Handler:    _Data_DeleteStringHistoricalData_Handler,
		},
		{
			MethodName: "DeleteBoolHistoricalData",
			Handler:    _Data_DeleteBoolHistoricalData_Handler,
		},
		{
			MethodName: "CleanItemData",
			Handler:    _Data_CleanItemData_Handler,
		},
		{
			MethodName: "ReLoadDb",
			Handler:    _Data_ReLoadDb_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BatchWriteFloatDataWithStream",
			Handler:       _Data_BatchWriteFloatDataWithStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchWriteIntDataWithStream",
			Handler:       _Data_BatchWriteIntDataWithStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchWriteStringDataWithStream",
			Handler:       _Data_BatchWriteStringDataWithStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchWriteBoolDataWithStream",
			Handler:       _Data_BatchWriteBoolDataWithStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchWriteFloatHistoricalDataWithStream",
			Handler:       _Data_BatchWriteFloatHistoricalDataWithStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchWriteIntHistoricalDataWithStream",
			Handler:       _Data_BatchWriteIntHistoricalDataWithStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchWriteStringHistoricalDataWithStream",
			Handler:       _Data_BatchWriteStringHistoricalDataWithStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchWriteBoolHistoricalDataWithStream",
			Handler:       _Data_BatchWriteBoolHistoricalDataWithStream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gdb.proto",
}

// PageClient is the client API for Page service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PageClient interface {
	UserLogin(ctx context.Context, in *AuthInfo, opts ...grpc.CallOption) (*UserToken, error)
	UserLogOut(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetUserInfo(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*UserInfo, error)
	GetUsers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserInfos, error)
	AddUsers(ctx context.Context, in *AddedUserInfo, opts ...grpc.CallOption) (*TimeRows, error)
	DeleteUsers(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*TimeRows, error)
	UpdateUsers(ctx context.Context, in *UpdatedUserInfo, opts ...grpc.CallOption) (*TimeRows, error)
	UploadFile(ctx context.Context, in *UploadedFileInfo, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UploadFileWithStream(ctx context.Context, opts ...grpc.CallOption) (Page_UploadFileWithStreamClient, error)
	AddItemsByExcel(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*TimeRows, error)
	ImportHistoryByExcel(ctx context.Context, in *HistoryFileInfo, opts ...grpc.CallOption) (*TimeRows, error)
	GetLogs(ctx context.Context, in *QueryLogsInfo, opts ...grpc.CallOption) (*LogsInfo, error)
	GetJsCode(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*Code, error)
	DeleteLogs(ctx context.Context, in *DeletedLogInfo, opts ...grpc.CallOption) (*TimeRows, error)
	DownloadFile(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileContents, error)
	GetDbSize(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FileSize, error)
	GetDbInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GdbInfoData, error)
	GetDbInfoHistory(ctx context.Context, in *QuerySpeedHistoryDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error)
	GetRoutes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Routes, error)
	DeleteRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*TimeRows, error)
	AddRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*TimeRows, error)
	AddUserRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*TimeRows, error)
	DeleteUserRoutes(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*TimeRows, error)
	GetAllRoutes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Routes, error)
	CheckRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*CheckResult, error)
}

type pageClient struct {
	cc grpc.ClientConnInterface
}

func NewPageClient(cc grpc.ClientConnInterface) PageClient {
	return &pageClient{cc}
}

func (c *pageClient) UserLogin(ctx context.Context, in *AuthInfo, opts ...grpc.CallOption) (*UserToken, error) {
	out := new(UserToken)
	err := c.cc.Invoke(ctx, "/model.Page/UserLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) UserLogOut(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/model.Page/UserLogOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetUserInfo(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*UserInfo, error) {
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, "/model.Page/GetUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetUsers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserInfos, error) {
	out := new(UserInfos)
	err := c.cc.Invoke(ctx, "/model.Page/GetUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) AddUsers(ctx context.Context, in *AddedUserInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Page/AddUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) DeleteUsers(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Page/DeleteUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) UpdateUsers(ctx context.Context, in *UpdatedUserInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Page/UpdateUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) UploadFile(ctx context.Context, in *UploadedFileInfo, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/model.Page/UploadFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) UploadFileWithStream(ctx context.Context, opts ...grpc.CallOption) (Page_UploadFileWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Page_ServiceDesc.Streams[0], "/model.Page/UploadFileWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &pageUploadFileWithStreamClient{stream}
	return x, nil
}

type Page_UploadFileWithStreamClient interface {
	Send(*UploadedFileInfo) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type pageUploadFileWithStreamClient struct {
	grpc.ClientStream
}

func (x *pageUploadFileWithStreamClient) Send(m *UploadedFileInfo) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pageUploadFileWithStreamClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pageClient) AddItemsByExcel(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Page/AddItemsByExcel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) ImportHistoryByExcel(ctx context.Context, in *HistoryFileInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Page/ImportHistoryByExcel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetLogs(ctx context.Context, in *QueryLogsInfo, opts ...grpc.CallOption) (*LogsInfo, error) {
	out := new(LogsInfo)
	err := c.cc.Invoke(ctx, "/model.Page/GetLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetJsCode(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*Code, error) {
	out := new(Code)
	err := c.cc.Invoke(ctx, "/model.Page/GetJsCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) DeleteLogs(ctx context.Context, in *DeletedLogInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Page/DeleteLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) DownloadFile(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileContents, error) {
	out := new(FileContents)
	err := c.cc.Invoke(ctx, "/model.Page/DownloadFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetDbSize(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FileSize, error) {
	out := new(FileSize)
	err := c.cc.Invoke(ctx, "/model.Page/GetDbSize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetDbInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GdbInfoData, error) {
	out := new(GdbInfoData)
	err := c.cc.Invoke(ctx, "/model.Page/GetDbInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetDbInfoHistory(ctx context.Context, in *QuerySpeedHistoryDataString, opts ...grpc.CallOption) (*GdbHistoricalData, error) {
	out := new(GdbHistoricalData)
	err := c.cc.Invoke(ctx, "/model.Page/GetDbInfoHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetRoutes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Routes, error) {
	out := new(Routes)
	err := c.cc.Invoke(ctx, "/model.Page/GetRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) DeleteRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Page/DeleteRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) AddRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Page/AddRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) AddUserRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Page/AddUserRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) DeleteUserRoutes(ctx context.Context, in *UserName, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Page/DeleteUserRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) GetAllRoutes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Routes, error) {
	out := new(Routes)
	err := c.cc.Invoke(ctx, "/model.Page/GetAllRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageClient) CheckRoutes(ctx context.Context, in *RoutesInfo, opts ...grpc.CallOption) (*CheckResult, error) {
	out := new(CheckResult)
	err := c.cc.Invoke(ctx, "/model.Page/CheckRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PageServer is the server API for Page service.
// All implementations must embed UnimplementedPageServer
// for forward compatibility
type PageServer interface {
	UserLogin(context.Context, *AuthInfo) (*UserToken, error)
	UserLogOut(context.Context, *UserName) (*emptypb.Empty, error)
	GetUserInfo(context.Context, *UserName) (*UserInfo, error)
	GetUsers(context.Context, *emptypb.Empty) (*UserInfos, error)
	AddUsers(context.Context, *AddedUserInfo) (*TimeRows, error)
	DeleteUsers(context.Context, *UserName) (*TimeRows, error)
	UpdateUsers(context.Context, *UpdatedUserInfo) (*TimeRows, error)
	UploadFile(context.Context, *UploadedFileInfo) (*emptypb.Empty, error)
	UploadFileWithStream(Page_UploadFileWithStreamServer) error
	AddItemsByExcel(context.Context, *FileInfo) (*TimeRows, error)
	ImportHistoryByExcel(context.Context, *HistoryFileInfo) (*TimeRows, error)
	GetLogs(context.Context, *QueryLogsInfo) (*LogsInfo, error)
	GetJsCode(context.Context, *FileInfo) (*Code, error)
	DeleteLogs(context.Context, *DeletedLogInfo) (*TimeRows, error)
	DownloadFile(context.Context, *FileInfo) (*FileContents, error)
	GetDbSize(context.Context, *emptypb.Empty) (*FileSize, error)
	GetDbInfo(context.Context, *emptypb.Empty) (*GdbInfoData, error)
	GetDbInfoHistory(context.Context, *QuerySpeedHistoryDataString) (*GdbHistoricalData, error)
	GetRoutes(context.Context, *emptypb.Empty) (*Routes, error)
	DeleteRoutes(context.Context, *RoutesInfo) (*TimeRows, error)
	AddRoutes(context.Context, *RoutesInfo) (*TimeRows, error)
	AddUserRoutes(context.Context, *RoutesInfo) (*TimeRows, error)
	DeleteUserRoutes(context.Context, *UserName) (*TimeRows, error)
	GetAllRoutes(context.Context, *emptypb.Empty) (*Routes, error)
	CheckRoutes(context.Context, *RoutesInfo) (*CheckResult, error)
	mustEmbedUnimplementedPageServer()
}

// UnimplementedPageServer must be embedded to have forward compatible implementations.
type UnimplementedPageServer struct {
}

func (UnimplementedPageServer) UserLogin(context.Context, *AuthInfo) (*UserToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedPageServer) UserLogOut(context.Context, *UserName) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogOut not implemented")
}
func (UnimplementedPageServer) GetUserInfo(context.Context, *UserName) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedPageServer) GetUsers(context.Context, *emptypb.Empty) (*UserInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}
func (UnimplementedPageServer) AddUsers(context.Context, *AddedUserInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUsers not implemented")
}
func (UnimplementedPageServer) DeleteUsers(context.Context, *UserName) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUsers not implemented")
}
func (UnimplementedPageServer) UpdateUsers(context.Context, *UpdatedUserInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUsers not implemented")
}
func (UnimplementedPageServer) UploadFile(context.Context, *UploadedFileInfo) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (UnimplementedPageServer) UploadFileWithStream(Page_UploadFileWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadFileWithStream not implemented")
}
func (UnimplementedPageServer) AddItemsByExcel(context.Context, *FileInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddItemsByExcel not implemented")
}
func (UnimplementedPageServer) ImportHistoryByExcel(context.Context, *HistoryFileInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportHistoryByExcel not implemented")
}
func (UnimplementedPageServer) GetLogs(context.Context, *QueryLogsInfo) (*LogsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogs not implemented")
}
func (UnimplementedPageServer) GetJsCode(context.Context, *FileInfo) (*Code, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJsCode not implemented")
}
func (UnimplementedPageServer) DeleteLogs(context.Context, *DeletedLogInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLogs not implemented")
}
func (UnimplementedPageServer) DownloadFile(context.Context, *FileInfo) (*FileContents, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadFile not implemented")
}
func (UnimplementedPageServer) GetDbSize(context.Context, *emptypb.Empty) (*FileSize, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDbSize not implemented")
}
func (UnimplementedPageServer) GetDbInfo(context.Context, *emptypb.Empty) (*GdbInfoData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDbInfo not implemented")
}
func (UnimplementedPageServer) GetDbInfoHistory(context.Context, *QuerySpeedHistoryDataString) (*GdbHistoricalData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDbInfoHistory not implemented")
}
func (UnimplementedPageServer) GetRoutes(context.Context, *emptypb.Empty) (*Routes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutes not implemented")
}
func (UnimplementedPageServer) DeleteRoutes(context.Context, *RoutesInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoutes not implemented")
}
func (UnimplementedPageServer) AddRoutes(context.Context, *RoutesInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRoutes not implemented")
}
func (UnimplementedPageServer) AddUserRoutes(context.Context, *RoutesInfo) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserRoutes not implemented")
}
func (UnimplementedPageServer) DeleteUserRoutes(context.Context, *UserName) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserRoutes not implemented")
}
func (UnimplementedPageServer) GetAllRoutes(context.Context, *emptypb.Empty) (*Routes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllRoutes not implemented")
}
func (UnimplementedPageServer) CheckRoutes(context.Context, *RoutesInfo) (*CheckResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckRoutes not implemented")
}
func (UnimplementedPageServer) mustEmbedUnimplementedPageServer() {}

// UnsafePageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PageServer will
// result in compilation errors.
type UnsafePageServer interface {
	mustEmbedUnimplementedPageServer()
}

func RegisterPageServer(s grpc.ServiceRegistrar, srv PageServer) {
	s.RegisterService(&Page_ServiceDesc, srv)
}

func _Page_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/UserLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).UserLogin(ctx, req.(*AuthInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_UserLogOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).UserLogOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/UserLogOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).UserLogOut(ctx, req.(*UserName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetUserInfo(ctx, req.(*UserName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetUsers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_AddUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddedUserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).AddUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/AddUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).AddUsers(ctx, req.(*AddedUserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_DeleteUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).DeleteUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/DeleteUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).DeleteUsers(ctx, req.(*UserName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_UpdateUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatedUserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).UpdateUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/UpdateUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).UpdateUsers(ctx, req.(*UpdatedUserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_UploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadedFileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).UploadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/UploadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).UploadFile(ctx, req.(*UploadedFileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_UploadFileWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PageServer).UploadFileWithStream(&pageUploadFileWithStreamServer{stream})
}

type Page_UploadFileWithStreamServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*UploadedFileInfo, error)
	grpc.ServerStream
}

type pageUploadFileWithStreamServer struct {
	grpc.ServerStream
}

func (x *pageUploadFileWithStreamServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pageUploadFileWithStreamServer) Recv() (*UploadedFileInfo, error) {
	m := new(UploadedFileInfo)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Page_AddItemsByExcel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).AddItemsByExcel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/AddItemsByExcel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).AddItemsByExcel(ctx, req.(*FileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_ImportHistoryByExcel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HistoryFileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).ImportHistoryByExcel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/ImportHistoryByExcel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).ImportHistoryByExcel(ctx, req.(*HistoryFileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLogsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetLogs(ctx, req.(*QueryLogsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetJsCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetJsCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetJsCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetJsCode(ctx, req.(*FileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_DeleteLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletedLogInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).DeleteLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/DeleteLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).DeleteLogs(ctx, req.(*DeletedLogInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_DownloadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).DownloadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/DownloadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).DownloadFile(ctx, req.(*FileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetDbSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetDbSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetDbSize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetDbSize(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetDbInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetDbInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetDbInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetDbInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetDbInfoHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySpeedHistoryDataString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetDbInfoHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetDbInfoHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetDbInfoHistory(ctx, req.(*QuerySpeedHistoryDataString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetRoutes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_DeleteRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).DeleteRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/DeleteRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).DeleteRoutes(ctx, req.(*RoutesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_AddRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).AddRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/AddRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).AddRoutes(ctx, req.(*RoutesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_AddUserRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).AddUserRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/AddUserRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).AddUserRoutes(ctx, req.(*RoutesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_DeleteUserRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).DeleteUserRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/DeleteUserRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).DeleteUserRoutes(ctx, req.(*UserName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_GetAllRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).GetAllRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/GetAllRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).GetAllRoutes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Page_CheckRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutesInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServer).CheckRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Page/CheckRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServer).CheckRoutes(ctx, req.(*RoutesInfo))
	}
	return interceptor(ctx, in, info, handler)
}

// Page_ServiceDesc is the grpc.ServiceDesc for Page service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Page_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.Page",
	HandlerType: (*PageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserLogin",
			Handler:    _Page_UserLogin_Handler,
		},
		{
			MethodName: "UserLogOut",
			Handler:    _Page_UserLogOut_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _Page_GetUserInfo_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _Page_GetUsers_Handler,
		},
		{
			MethodName: "AddUsers",
			Handler:    _Page_AddUsers_Handler,
		},
		{
			MethodName: "DeleteUsers",
			Handler:    _Page_DeleteUsers_Handler,
		},
		{
			MethodName: "UpdateUsers",
			Handler:    _Page_UpdateUsers_Handler,
		},
		{
			MethodName: "UploadFile",
			Handler:    _Page_UploadFile_Handler,
		},
		{
			MethodName: "AddItemsByExcel",
			Handler:    _Page_AddItemsByExcel_Handler,
		},
		{
			MethodName: "ImportHistoryByExcel",
			Handler:    _Page_ImportHistoryByExcel_Handler,
		},
		{
			MethodName: "GetLogs",
			Handler:    _Page_GetLogs_Handler,
		},
		{
			MethodName: "GetJsCode",
			Handler:    _Page_GetJsCode_Handler,
		},
		{
			MethodName: "DeleteLogs",
			Handler:    _Page_DeleteLogs_Handler,
		},
		{
			MethodName: "DownloadFile",
			Handler:    _Page_DownloadFile_Handler,
		},
		{
			MethodName: "GetDbSize",
			Handler:    _Page_GetDbSize_Handler,
		},
		{
			MethodName: "GetDbInfo",
			Handler:    _Page_GetDbInfo_Handler,
		},
		{
			MethodName: "GetDbInfoHistory",
			Handler:    _Page_GetDbInfoHistory_Handler,
		},
		{
			MethodName: "GetRoutes",
			Handler:    _Page_GetRoutes_Handler,
		},
		{
			MethodName: "DeleteRoutes",
			Handler:    _Page_DeleteRoutes_Handler,
		},
		{
			MethodName: "AddRoutes",
			Handler:    _Page_AddRoutes_Handler,
		},
		{
			MethodName: "AddUserRoutes",
			Handler:    _Page_AddUserRoutes_Handler,
		},
		{
			MethodName: "DeleteUserRoutes",
			Handler:    _Page_DeleteUserRoutes_Handler,
		},
		{
			MethodName: "GetAllRoutes",
			Handler:    _Page_GetAllRoutes_Handler,
		},
		{
			MethodName: "CheckRoutes",
			Handler:    _Page_CheckRoutes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFileWithStream",
			Handler:       _Page_UploadFileWithStream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gdb.proto",
}

// CalcClient is the client API for Calc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CalcClient interface {
	TestCalcItem(ctx context.Context, in *TestCalcItemInfo, opts ...grpc.CallOption) (*CalculationResult, error)
	AddCalcItem(ctx context.Context, in *AddedCalcItemInfo, opts ...grpc.CallOption) (*CalculationResult, error)
	AddCalcItemWithStream(ctx context.Context, opts ...grpc.CallOption) (Calc_AddCalcItemWithStreamClient, error)
	GetCalcItems(ctx context.Context, in *QueryCalcItemsInfo, opts ...grpc.CallOption) (*CalcItemsInfo, error)
	UpdateCalcItem(ctx context.Context, in *UpdatedCalcInfo, opts ...grpc.CallOption) (*CalculationResult, error)
	StartCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*TimeRows, error)
	StopCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*TimeRows, error)
	DeleteCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*TimeRows, error)
}

type calcClient struct {
	cc grpc.ClientConnInterface
}

func NewCalcClient(cc grpc.ClientConnInterface) CalcClient {
	return &calcClient{cc}
}

func (c *calcClient) TestCalcItem(ctx context.Context, in *TestCalcItemInfo, opts ...grpc.CallOption) (*CalculationResult, error) {
	out := new(CalculationResult)
	err := c.cc.Invoke(ctx, "/model.Calc/TestCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) AddCalcItem(ctx context.Context, in *AddedCalcItemInfo, opts ...grpc.CallOption) (*CalculationResult, error) {
	out := new(CalculationResult)
	err := c.cc.Invoke(ctx, "/model.Calc/AddCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) AddCalcItemWithStream(ctx context.Context, opts ...grpc.CallOption) (Calc_AddCalcItemWithStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Calc_ServiceDesc.Streams[0], "/model.Calc/AddCalcItemWithStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &calcAddCalcItemWithStreamClient{stream}
	return x, nil
}

type Calc_AddCalcItemWithStreamClient interface {
	Send(*AddedCalcItemInfo) error
	CloseAndRecv() (*CalculationResults, error)
	grpc.ClientStream
}

type calcAddCalcItemWithStreamClient struct {
	grpc.ClientStream
}

func (x *calcAddCalcItemWithStreamClient) Send(m *AddedCalcItemInfo) error {
	return x.ClientStream.SendMsg(m)
}

func (x *calcAddCalcItemWithStreamClient) CloseAndRecv() (*CalculationResults, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CalculationResults)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *calcClient) GetCalcItems(ctx context.Context, in *QueryCalcItemsInfo, opts ...grpc.CallOption) (*CalcItemsInfo, error) {
	out := new(CalcItemsInfo)
	err := c.cc.Invoke(ctx, "/model.Calc/GetCalcItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) UpdateCalcItem(ctx context.Context, in *UpdatedCalcInfo, opts ...grpc.CallOption) (*CalculationResult, error) {
	out := new(CalculationResult)
	err := c.cc.Invoke(ctx, "/model.Calc/UpdateCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) StartCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Calc/StartCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) StopCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Calc/StopCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calcClient) DeleteCalcItem(ctx context.Context, in *CalcId, opts ...grpc.CallOption) (*TimeRows, error) {
	out := new(TimeRows)
	err := c.cc.Invoke(ctx, "/model.Calc/DeleteCalcItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CalcServer is the server API for Calc service.
// All implementations must embed UnimplementedCalcServer
// for forward compatibility
type CalcServer interface {
	TestCalcItem(context.Context, *TestCalcItemInfo) (*CalculationResult, error)
	AddCalcItem(context.Context, *AddedCalcItemInfo) (*CalculationResult, error)
	AddCalcItemWithStream(Calc_AddCalcItemWithStreamServer) error
	GetCalcItems(context.Context, *QueryCalcItemsInfo) (*CalcItemsInfo, error)
	UpdateCalcItem(context.Context, *UpdatedCalcInfo) (*CalculationResult, error)
	StartCalcItem(context.Context, *CalcId) (*TimeRows, error)
	StopCalcItem(context.Context, *CalcId) (*TimeRows, error)
	DeleteCalcItem(context.Context, *CalcId) (*TimeRows, error)
	mustEmbedUnimplementedCalcServer()
}

// UnimplementedCalcServer must be embedded to have forward compatible implementations.
type UnimplementedCalcServer struct {
}

func (UnimplementedCalcServer) TestCalcItem(context.Context, *TestCalcItemInfo) (*CalculationResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestCalcItem not implemented")
}
func (UnimplementedCalcServer) AddCalcItem(context.Context, *AddedCalcItemInfo) (*CalculationResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCalcItem not implemented")
}
func (UnimplementedCalcServer) AddCalcItemWithStream(Calc_AddCalcItemWithStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method AddCalcItemWithStream not implemented")
}
func (UnimplementedCalcServer) GetCalcItems(context.Context, *QueryCalcItemsInfo) (*CalcItemsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCalcItems not implemented")
}
func (UnimplementedCalcServer) UpdateCalcItem(context.Context, *UpdatedCalcInfo) (*CalculationResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCalcItem not implemented")
}
func (UnimplementedCalcServer) StartCalcItem(context.Context, *CalcId) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartCalcItem not implemented")
}
func (UnimplementedCalcServer) StopCalcItem(context.Context, *CalcId) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopCalcItem not implemented")
}
func (UnimplementedCalcServer) DeleteCalcItem(context.Context, *CalcId) (*TimeRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCalcItem not implemented")
}
func (UnimplementedCalcServer) mustEmbedUnimplementedCalcServer() {}

// UnsafeCalcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CalcServer will
// result in compilation errors.
type UnsafeCalcServer interface {
	mustEmbedUnimplementedCalcServer()
}

func RegisterCalcServer(s grpc.ServiceRegistrar, srv CalcServer) {
	s.RegisterService(&Calc_ServiceDesc, srv)
}

func _Calc_TestCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestCalcItemInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).TestCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/TestCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).TestCalcItem(ctx, req.(*TestCalcItemInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_AddCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddedCalcItemInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).AddCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/AddCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).AddCalcItem(ctx, req.(*AddedCalcItemInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_AddCalcItemWithStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CalcServer).AddCalcItemWithStream(&calcAddCalcItemWithStreamServer{stream})
}

type Calc_AddCalcItemWithStreamServer interface {
	SendAndClose(*CalculationResults) error
	Recv() (*AddedCalcItemInfo, error)
	grpc.ServerStream
}

type calcAddCalcItemWithStreamServer struct {
	grpc.ServerStream
}

func (x *calcAddCalcItemWithStreamServer) SendAndClose(m *CalculationResults) error {
	return x.ServerStream.SendMsg(m)
}

func (x *calcAddCalcItemWithStreamServer) Recv() (*AddedCalcItemInfo, error) {
	m := new(AddedCalcItemInfo)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Calc_GetCalcItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCalcItemsInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).GetCalcItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/GetCalcItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).GetCalcItems(ctx, req.(*QueryCalcItemsInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_UpdateCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatedCalcInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).UpdateCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/UpdateCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).UpdateCalcItem(ctx, req.(*UpdatedCalcInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_StartCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalcId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).StartCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/StartCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).StartCalcItem(ctx, req.(*CalcId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_StopCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalcId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).StopCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/StopCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).StopCalcItem(ctx, req.(*CalcId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calc_DeleteCalcItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalcId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalcServer).DeleteCalcItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Calc/DeleteCalcItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalcServer).DeleteCalcItem(ctx, req.(*CalcId))
	}
	return interceptor(ctx, in, info, handler)
}

// Calc_ServiceDesc is the grpc.ServiceDesc for Calc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Calc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.Calc",
	HandlerType: (*CalcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TestCalcItem",
			Handler:    _Calc_TestCalcItem_Handler,
		},
		{
			MethodName: "AddCalcItem",
			Handler:    _Calc_AddCalcItem_Handler,
		},
		{
			MethodName: "GetCalcItems",
			Handler:    _Calc_GetCalcItems_Handler,
		},
		{
			MethodName: "UpdateCalcItem",
			Handler:    _Calc_UpdateCalcItem_Handler,
		},
		{
			MethodName: "StartCalcItem",
			Handler:    _Calc_StartCalcItem_Handler,
		},
		{
			MethodName: "StopCalcItem",
			Handler:    _Calc_StopCalcItem_Handler,
		},
		{
			MethodName: "DeleteCalcItem",
			Handler:    _Calc_DeleteCalcItem_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AddCalcItemWithStream",
			Handler:       _Calc_AddCalcItemWithStream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gdb.proto",
}
